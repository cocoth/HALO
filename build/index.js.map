{"version":3,"sources":["../index.ts","../src/utils/colors.ts","../src/utils/time.ts","../src/utils/logger.ts","../src/core/agent.ts","../src/lib/iof.ts","../src/utils/mimeType.ts","../src/core/tools.ts","../src/utils/hash.ts","../src/utils/terminal.ts","../src/lib/session.ts"],"sourcesContent":["export * from \"@/core/agent\"\r\nexport * from \"@/core/tools\"\r\nexport * from \"@/lib/iof\"\r\nexport * from \"@/utils/colors\"\r\nexport * from \"@/utils/hash\"\r\nexport * from \"@/utils/logger\"\r\nexport * from \"@/utils/mimeType\"\r\nexport * as Terminal from \"@/utils/terminal\"\r\nexport * from \"@/utils/time\"\r\nexport * from \"@/lib/session\"\r\nexport * from \"@/types/index\"\r\n\r\nexport { tool } from \"ai\"\r\nexport type { CoreMessage, ToolSet } from \"ai\"","/**\r\n * Utility functions for terminal colors.\r\n * These functions provide ANSI escape codes for styling terminal output.\r\n * @module TerminalColors\r\n * This module exports an object containing ANSI escape codes for various text styles and colors.\r\n * You can use these codes to format terminal output in Node.js applications.\r\n * @example\r\n * import { TerminalColors as TC } from '@/shared/utils/colors';\r\n * console.log(`${TC.RED}This text is red${TC._reset}`);\r\n * @see {@link https://en.wikipedia.org/wiki/ANSI_escape_code} for more information\r\n */\r\nexport const TerminalColors = {\r\n    /**\r\n     * reset - Resets all styles and colors to default.\r\n     * This code is used to reset the terminal text formatting to its default state.\r\n     */\r\n    _reset: '\\x1b[0m',\r\n    /**\r\n     * bright - Makes the text bright.\r\n     * This code is used to make the terminal text bright or bold.\r\n     */\r\n    _bright: '\\x1b[1m',\r\n    /**\r\n     * dim - Makes the text dim.\r\n     * This code is used to make the terminal text dim or less bright.\r\n     */\r\n    _dim: '\\x1b[2m',\r\n    /**\r\n     * italic - Makes the text italic.\r\n     * This code is used to make the terminal text italicized.\r\n     */\r\n    _italic: '\\x1b[3m',\r\n    /**\r\n     * underline - Underlines the text.\r\n     * This code is used to underline the terminal text.\r\n     */\r\n    _underline: '\\x1b[4m',\r\n    /**\r\n     * blink - Makes the text blink.\r\n     * This code is used to make the terminal text blink.\r\n     */\r\n    _blink: '\\x1b[5m',\r\n    /**\r\n     * reverse - Reverses the foreground and background colors.\r\n     * This code is used to swap the foreground and background colors of the terminal text.\r\n     */\r\n    _reverse: '\\x1b[7m',\r\n    /**\r\n     * hidden - Hides the text.\r\n     * This code is used to hide the terminal text, making it invisible.\r\n     */\r\n    _hidden: '\\x1b[8m',\r\n    /**\r\n     * strikethrough - Strikes through the text.\r\n     * This code is used to add a strikethrough effect to the terminal text.\r\n     */\r\n    _strikethrough: '\\x1b[9m',\r\n\r\n    // Foreground colors\r\n    /**\r\n     * BLACK - Sets the text color to black.\r\n     * This code is used to change the terminal text color to black.\r\n     */\r\n    BLACK: '\\x1b[30m',\r\n    /**\r\n     * RED - Sets the text color to red.\r\n     * This code is used to change the terminal text color to red.\r\n     */\r\n    RED: '\\x1b[31m',\r\n    /**\r\n     * GREEN - Sets the text color to green.\r\n     * This code is used to change the terminal text color to green.\r\n     */\r\n    GREEN: '\\x1b[32m',\r\n    /**\r\n     * YELLOW - Sets the text color to yellow.\r\n     * This code is used to change the terminal text color to yellow.\r\n     */\r\n    YELLOW: '\\x1b[33m',\r\n    /**\r\n     * BLUE - Sets the text color to blue.\r\n     * This code is used to change the terminal text color to blue.\r\n     */\r\n    BLUE: '\\x1b[34m',\r\n    /**\r\n     * MAGENTA - Sets the text color to magenta.\r\n     * This code is used to change the terminal text color to magenta.\r\n     */\r\n    MAGENTA: '\\x1b[35m',\r\n    /**\r\n     * CYAN - Sets the text color to cyan.\r\n     * This code is used to change the terminal text color to cyan.\r\n     */\r\n    CYAN: '\\x1b[36m',\r\n    /**\r\n     * WHITE - Sets the text color to white.\r\n     * This code is used to change the terminal text color to white.\r\n     */\r\n    WHITE: '\\x1b[37m',\r\n\r\n    // Bright foreground colors\r\n    /**\r\n     * BBLACK - Sets the text color to bright black (gray).\r\n     * This code is used to change the terminal text color to bright black.\r\n     */\r\n    BBLACK: '\\x1b[40m',\r\n    /**\r\n     * BRED - Sets the background color to bright red.\r\n     * This code is used to change the terminal background color to bright red.\r\n     */\r\n    BRED: '\\x1b[41m',\r\n    /**\r\n     * BGREEN - Sets the background color to bright green.\r\n     * This code is used to change the terminal background color to bright green.\r\n     */\r\n    BGREEN: '\\x1b[42m',\r\n    /**\r\n     * BYELLOW - Sets the background color to bright yellow.\r\n     * This code is used to change the terminal background color to bright yellow.\r\n     */\r\n    BYELLOW: '\\x1b[43m',\r\n    /**\r\n     * BBLUE - Sets the background color to bright blue.\r\n     * This code is used to change the terminal background color to bright blue.\r\n     */\r\n    BBLUE: '\\x1b[44m',\r\n    /**\r\n     * BMAGENTA - Sets the background color to bright magenta.\r\n     * This code is used to change the terminal background color to bright magenta.\r\n     */\r\n    BMAGENTA: '\\x1b[45m',\r\n    /**\r\n     * BCYAN - Sets the background color to bright cyan.\r\n     * This code is used to change the terminal background color to bright cyan.\r\n     */\r\n    BCYAN: '\\x1b[46m',\r\n    /**\r\n     * BWHITE - Sets the background color to bright white.\r\n     * This code is used to change the terminal background color to bright white.\r\n     */\r\n    BWHITE: '\\x1b[47m'\r\n};","\r\n/**\r\n * Time utility class for handling date and time formatting.\r\n * This class provides methods to format dates in various ways, including human-readable formats,\r\n * ISO strings, and formats suitable for logging or saving to a database.\r\n */\r\nexport class Time {\r\n  private static formatDateToParts(\r\n    date: Date,\r\n    locale?: string | null,\r\n    timeZone?: string | null\r\n  ): { [key: string]: string } {\r\n\r\n    const systemLocale = locale || Time.getSystemLocale();\r\n    const systemTimeZone = timeZone || Time.getSystemTimezone();\r\n\r\n    const formatter = new Intl.DateTimeFormat(systemLocale, {\r\n      timeZone: systemTimeZone,\r\n      year: \"numeric\",\r\n      month: \"2-digit\",\r\n      day: \"2-digit\",\r\n      hour: \"2-digit\",\r\n      minute: \"2-digit\",\r\n      second: \"2-digit\",\r\n      hour12: false,\r\n    });\r\n\r\n    const formattedParts = formatter.formatToParts(date);\r\n    const dateParts: { [key: string]: string } = {};\r\n\r\n    formattedParts.forEach(({ type, value }) => {\r\n      dateParts[type] = value;\r\n    });\r\n\r\n    return dateParts;\r\n  }\r\n\r\n  private static formatDateString(dateParts: { [key: string]: string }): string {\r\n    return `${dateParts.year}-${dateParts.month}-${dateParts.day}T${dateParts.hour}:${dateParts.minute}:${dateParts.second}Z`;\r\n  }\r\n\r\n  private static formateDateToSaveString(dateParts: { [key: string]: string }): string {\r\n    return `${dateParts.year}-${dateParts.month}-${dateParts.day}T${dateParts.hour}-${dateParts.minute}-${dateParts.second}Z`;\r\n  }\r\n\r\n  private static logFormat(dateParts: { [key: string]: string }): string {\r\n    return `${dateParts.day}/${dateParts.month}/${dateParts.year}:${dateParts.hour}:${dateParts.minute}:${dateParts.second}`;\r\n  }\r\n\r\n  /**\r\n   * Gets the system's default timezone\r\n   */\r\n  public static getSystemTimezone(): string {\r\n    return Intl.DateTimeFormat().resolvedOptions().timeZone;\r\n  }\r\n\r\n  /**\r\n   * Gets the system's default locale\r\n   */\r\n  public static getSystemLocale(): string {\r\n    return Intl.DateTimeFormat().resolvedOptions().locale;\r\n  }\r\n\r\n  /**\r\n   * Gets both system locale and timezone\r\n   */\r\n  public static getSystemLocaleAndTimezone(): { locale: string; timeZone: string } {\r\n    const resolved = Intl.DateTimeFormat().resolvedOptions();\r\n    return {\r\n      locale: resolved.locale,\r\n      timeZone: resolved.timeZone\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Formats a date to a human-readable string.\r\n   * @param date The date to format.\r\n   * @param timeZone The time zone to use for formatting.\r\n   * @returns The formatted date string.\r\n   */\r\n  public static formatDateToHumanReadable(data: {\r\n    date?: Date;\r\n    locale?: string | null;\r\n    timeZone?: string | null;\r\n  }): string {\r\n    const { date, locale, timeZone } = data;\r\n    const now = new Date();\r\n    const dateParts = Time.formatDateToParts(date || now, locale, timeZone);\r\n    return `${dateParts.day}/${dateParts.month}/${dateParts.year} ${dateParts.hour}:${dateParts.minute}:${dateParts.second}`;\r\n  }\r\n\r\n  /**\r\n   * Returns the current time formatted as a string suitable for saving.\r\n   * This format is `YYYY-MM-DDTHH-MM-SSZ`, which is useful for file naming or database storage.\r\n   */\r\n  public static getCurrentTimeToSaveString(\r\n    locale?: string | null,\r\n    timeZone?: string | null\r\n  ): string {\r\n    const now = new Date();\r\n    const dateParts = Time.formatDateToParts(now, locale, timeZone);\r\n    return Time.formateDateToSaveString(dateParts);\r\n  }\r\n\r\n  /**\r\n   * Returns the current time as a Date object.\r\n   * This method formats the current time to a string and then converts it back to a Date object.\r\n   */\r\n  public static getCurrentTime(\r\n    locale?: string | null,\r\n    timeZone?: string | null\r\n  ): Date {\r\n    const now = new Date();\r\n    const dateParts = Time.formatDateToParts(now, locale, timeZone);\r\n    const formattedDateString = Time.formatDateString(dateParts);\r\n    return new Date(formattedDateString);\r\n  }\r\n\r\n  /**\r\n   * Returns the current time formatted as a string.\r\n   * This format is `YYYY-MM-DDTHH:MM:SSZ`, which is useful for logging or displaying the current time.\r\n   */\r\n  public static getCurrentTimeToString(\r\n    locale?: string | null,\r\n    timeZone?: string | null\r\n  ): string {\r\n    const now = new Date();\r\n    const dateParts = Time.formatDateToParts(now, locale, timeZone);\r\n    return Time.formatDateString(dateParts);\r\n  }\r\n\r\n  /**\r\n   * Returns the current time in a human-readable format.\r\n   * This format is `DD/MM/YYYY HH:MM:SS`, which is suitable for display to users.\r\n   */\r\n  public static getCurrentTimeToHumanReadable(\r\n    locale?: string | null,\r\n    timeZone?: string | null\r\n  ): string {\r\n    const now = new Date();\r\n    return Time.formatDateToHumanReadable({ date: now, locale, timeZone });\r\n  }\r\n\r\n  /**\r\n   * Returns the current time formatted for logging.\r\n   * This format is `DD/MM/YYYY:HH:MM:SS`, which is useful for log entries.\r\n   */\r\n  public static getTimeToLogFormat(\r\n    locale?: string | null,\r\n    timeZone?: string | null\r\n  ): string {\r\n    const now = new Date();\r\n    const dateParts = Time.formatDateToParts(now, locale, timeZone);\r\n    return Time.logFormat(dateParts);\r\n  }\r\n\r\n}\r\n","import { TerminalColors as TC } from \"@/utils/colors\";\r\nimport { Time } from \"@/utils/time\";\r\n\r\n\r\n\r\nexport class Logger {\r\n    private static log(type: \"DEBUG\" | \"WARN\" | \"ERROR\" | \"INFO\" | \"SUCCESS\", message: string, funcName?: string) {\r\n      const colorMap = {\r\n        DEBUG: TC.MAGENTA,\r\n        WARN: TC.BYELLOW,\r\n        ERROR: TC.RED,\r\n        INFO: TC.BLUE,\r\n        SUCCESS: TC.GREEN,\r\n      };\r\n      const color = colorMap[type] || TC._reset;\r\n      const currentTime = Time.getTimeToLogFormat();\r\n      const functionName = funcName ? `funcName: ${funcName}` : \"\";\r\n      const logMethod = type === \"ERROR\" || type === \"WARN\" ? console.log : type === \"INFO\" ? console.info : console.log;\r\n      logMethod(`${TC._dim}[${currentTime}]${TC._reset} ${color}[${type}]${TC._reset} ${functionName}: ${message}`);\r\n    }\r\n  \r\n    static success(message: string, funcName?: string) {\r\n      this.log(\"SUCCESS\", message, funcName);\r\n    }\r\n  \r\n    static error(message: string, funcName?: string) {\r\n      this.log(\"ERROR\", message, funcName);\r\n    }\r\n  \r\n    static warn(message: string, funcName?: string) {\r\n      this.log(\"WARN\", message, funcName);\r\n    }\r\n  \r\n    static info(message: string, funcName?: string) {\r\n      this.log(\"INFO\", message, funcName);\r\n    }\r\n  \r\n    static debug(message: string, funcName?: string) {\r\n      this.log(\"DEBUG\", message, funcName);\r\n    }\r\n\r\n    /**\r\n     * Custom logging function that allows specifying the type, message, color, and function name.\r\n     * @param type The type of log (e.g., \"DEBUG\", \"WARN\", \"ERROR\", \"INFO\", \"SUCCESS\").\r\n     * @param message The message to log.\r\n     * @param color Optional color for the log.\r\n     * @param funcName Optional function name for context.\r\n     */\r\n    static custom(\r\n      type: string,\r\n      message: string,\r\n      color?: keyof typeof TC,\r\n      funcName?: string\r\n    ) {\r\n      const logColor = color || \"CYAN\";\r\n\r\n      const functionName = funcName ? `funcName: ${funcName}` : \"\"\r\n      const currentTime = Time.getTimeToLogFormat()\r\n      console.log(`${TC._dim}[${currentTime}]${TC._reset} ${TC[logColor]}[${type}]${TC._reset} ${functionName}: ${message}`);\r\n    }\r\n  }\r\n  ","import { Logger } from \"@/utils/logger\";\r\nimport { createOpenAI } from \"@ai-sdk/openai\";\r\nimport { createGoogleGenerativeAI } from \"@ai-sdk/google\";\r\nimport {\r\n  CoreMessage,\r\n  generateObject,\r\n  generateText,\r\n  LanguageModelV1,\r\n  streamText,\r\n  ToolSet,\r\n} from \"ai\";\r\nimport { IOF } from \"@/lib/iof\";\r\nimport { TaskHandler } from \"@/core/tools\";\r\nimport type { AiAgentConfig, ChatBuilder, InlineData, ModelID, StartChatResult } from \"@/types\";\r\nimport { Schema, z } from \"zod\";\r\n\r\n/**\r\n * AiAgent class for interacting with an AI agent via OpenAI API.\r\n * It initializes the agent with a URL and API key, and allows starting a chat session.\r\n * This class provides methods to start a chat session, generate text responses, and handle various tasks.\r\n * @param {AiAgentConfig<ModelID>} config - Configuration for the AI agent.\r\n * @property {string} agentUrl - The URL of the AI agent service.\r\n * @property {string} apiKey - The API key for the AI agent.\r\n * @property {ModelID} model - The language model used for generating responses.\r\n * @property {ModelID} fallbackModel - Optional fallback model to use if the primary model fails.\r\n * @property {string} systemPrompt - The system prompt text to be used by the AI agent.\r\n * This can be a string or a file containing the prompt.\r\n * You can use either `file` or `text`, but not both.\r\n * @property {ToolSet} toolSet - Set of tools available for the AI agent to use.\r\n * @example\r\n * const agent = new AiAgent({\r\n *   agentUrl: \"https://api.example.com/ai\",\r\n *   apiKey: \"your-api-key\",\r\n *   model: \"gpt-4o\",\r\n *   fallbackModel: \"gpt-3.5-turbo\",\r\n *   systemPrompt: {\r\n *      text: \"You are a helpful assistant. Answer the questions as best you can.\",\r\n *   },\r\n *   tools: {\r\n *     getCurrentTime: TaskHandler.getCurrentTime\r\n *   }\r\n * });\r\n */\r\nexport class AiAgent {\r\n  private aiAgentUrl: string;\r\n  private apiKey: string;\r\n  private model: LanguageModelV1;\r\n  private fallbackModel?: ModelID;\r\n  private systemPromptFile?: string;\r\n  private systemPromptText?: string;\r\n  private streamMethod: \"text\" | \"stream\" = \"text\";\r\n  private toolSet: ToolSet = {\r\n    getCurrentTime: TaskHandler.getCurrentTime\r\n  };\r\n\r\n  private systemPromptCache?: string;\r\n\r\n  /**\r\n   * Loads the system prompt from a specified file.\r\n   * If the file is not found or empty, it throws an error.\r\n   */\r\n  private async systemPrompt(): Promise<string> {\r\n    if (this.systemPromptCache !== undefined) {\r\n      return this.systemPromptCache;\r\n    }\r\n\r\n    if (this.systemPromptText) {\r\n      this.systemPromptCache = this.systemPromptText;\r\n      return this.systemPromptCache;\r\n    }\r\n\r\n    if (this.systemPromptFile) {\r\n      try {\r\n        const system = await IOF.readTextFile(this.systemPromptFile);\r\n        if (!system) {\r\n          throw new Error(\"System prompt file not found or empty.\");\r\n        }\r\n        this.systemPromptCache = system;\r\n        return this.systemPromptCache;\r\n      } catch (error) {\r\n        throw new Error(`Failed to load system prompt: ${error instanceof Error ? error.message : String(error)}`);\r\n      }\r\n    }\r\n\r\n    this.systemPromptCache = \"\";\r\n    return this.systemPromptCache;\r\n  }\r\n\r\n  constructor(config: AiAgentConfig) {\r\n    try {\r\n      this.validateConfig(config);\r\n      this.aiAgentUrl = config.agentUrl;\r\n      this.apiKey = config.apiKey;\r\n      this.initializeProperties(config);\r\n      this.setupTools(config.tools);\r\n\r\n      // Initialize the model based on the provided configuration\r\n      this.model = this.initModel({\r\n        model: config.model,\r\n      });\r\n\r\n      // Set fallback model if provided\r\n      this.fallbackModel = config.fallbackModel;\r\n    } catch (error) {\r\n      throw new Error(`Invalid configuration: ${error}`);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Validates the configuration for the AI agent.\r\n   * @param config - The configuration to validate.\r\n   * @throws Will throw an error if the configuration is invalid.\r\n   */\r\n  private validateConfig(config: AiAgentConfig): void {\r\n    const errors: string[] = [];\r\n\r\n    if (!config.agentUrl) errors.push(\"Agent URL is required\");\r\n    if (!config.apiKey) errors.push(\"API key is required\");\r\n    if (!config.model) errors.push(\"Model is required\");\r\n\r\n    if (config.systemPrompt?.text && config.systemPrompt?.file) {\r\n      errors.push(\"Cannot use both systemPrompt.text and systemPrompt.file\");\r\n    }\r\n\r\n    if (errors.length > 0) {\r\n      throw new Error(`Configuration errors: ${errors.join(\", \")}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates the query parameters for the AI agent.\r\n   * @param session - Optional array of previous messages in the chat session.\r\n   * @param prompt - The user's message to start the chat.\r\n   * @throws Will throw an error if the prompt is not a string or if the session is not an array of CoreMessage.\r\n   */\r\n  private validateQueryParams({ session, prompt }: { session?: CoreMessage[] | null; prompt?: string }): void {\r\n    if (prompt && typeof prompt !== \"string\") {\r\n      throw new Error(\"Prompt must be a non-empty string.\");\r\n    }\r\n\r\n    if (session && !Array.isArray(session)) {\r\n      throw new Error(\"Session must be an array of CoreMessage.\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initializes the AI agent with the provided configuration.\r\n   * It sets up the agent URL, API key, model, and system prompt.\r\n   * @param config - The configuration for the AI agent.\r\n   */\r\n  private initializeProperties(config: AiAgentConfig): void {\r\n    this.systemPromptFile = config.systemPrompt?.file;\r\n    this.systemPromptText = config.systemPrompt?.text;\r\n  }\r\n\r\n  /**\r\n   * Sets up the tools for the AI agent.\r\n   * If tools are provided, they are merged with the default tool set.\r\n   * @param tools - Optional set of tools to be used by the AI agent.\r\n   */\r\n  private setupTools(tools?: ToolSet): void {\r\n    if (tools) {\r\n      this.toolSet = {\r\n        getCurrentTime: TaskHandler.getCurrentTime,\r\n        ...tools\r\n      };\r\n    }\r\n  }\r\n\r\n  private initModel({\r\n    model,\r\n  }: {\r\n    model?: ModelID\r\n  }): LanguageModelV1 {\r\n    if (model?.startsWith(\"gemini-\")) {\r\n      const googleModel = createGoogleGenerativeAI({\r\n        apiKey: this.apiKey,\r\n        baseURL: this.aiAgentUrl,\r\n      });\r\n      return googleModel(model, {\r\n        useSearchGrounding: true\r\n      });\r\n    } else if (model?.startsWith(\"gpt-\")) {\r\n      const openAIModel = createOpenAI({\r\n        baseURL: this.aiAgentUrl,\r\n        apiKey: this.apiKey,\r\n        compatibility: \"strict\",\r\n      });\r\n      return openAIModel(model);\r\n    }\r\n    const openAIModel = createOpenAI({\r\n      baseURL: this.aiAgentUrl,\r\n      apiKey: this.apiKey,\r\n      compatibility: \"strict\",\r\n    });\r\n    return openAIModel(\"gpt-4o\");\r\n  }\r\n\r\n\r\n  /**\r\n   * Generates an object based on either a prompt string or an array of messages, validated against a provided schema.\r\n   *\r\n   * @param messages - Optional array of `CoreMessage` objects to use as context for generation.\r\n   * @param prompt - Optional prompt string to use for generation. Must be a string if provided.\r\n   * @param schema - The schema (Zod or custom Schema) to validate the generated object against.\r\n   * @returns A promise that resolves to the generated object, validated by the provided schema.\r\n   * @throws Will throw an error if `prompt` is not a string or if `messages` is not an array of `CoreMessage`.\r\n   */\r\n  private async generateObject<OBJECT>({\r\n    messages,\r\n    schema\r\n  }: {\r\n    /**\r\n     * Optional array of `CoreMessage` objects to use as context for generation.\r\n     * If provided, it will be used instead of the prompt.\r\n     */\r\n    messages?: CoreMessage[];\r\n    /**\r\n     * The schema (Zod or custom Schema) to validate the generated object against.\r\n     * This is required to ensure the generated object conforms to the expected structure.\r\n     */\r\n    schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>;\r\n  }) {\r\n    return await generateObject({\r\n      model: this.model,\r\n      system: await this.systemPrompt(),\r\n      schema,\r\n      messages,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generates a stream of text responses based on the provided messages.\r\n   * It uses the AI agent's model and system prompt to generate the responses.\r\n   * If tools are defined, it will use them in the generation process.\r\n   *\r\n   * @param messages - An optional array of CoreMessage objects representing the conversation history.\r\n   * @param prompt - An optional prompt string to start the conversation.\r\n   * @returns A stream of text responses generated by the AI agent.\r\n   */\r\n  private async generateText({\r\n    messages,\r\n  }: {\r\n    /**\r\n     * An optional array of CoreMessage objects representing the conversation history.\r\n     * If provided, it will be used instead of the prompt.\r\n     */\r\n    messages?: CoreMessage[];\r\n  }) {\r\n    return await generateText({\r\n      model: this.model,\r\n      system: await this.systemPrompt(),\r\n      tools: Object.keys(this.toolSet).length > 0 ? this.toolSet : undefined,\r\n      maxSteps: Object.keys(this.toolSet).length > 0 ? Number.MAX_SAFE_INTEGER : undefined,\r\n      messages,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generates a text stream based on the provided messages.\r\n   * This method is used for streaming responses from the AI agent.\r\n   * It uses the `streamText` function from the `ai` library.\r\n   *\r\n   * @param messages - An array of CoreMessage objects representing the conversation history.\r\n   * @returns A stream of text responses from the AI agent.\r\n   */\r\n  private async generateStream({\r\n    messages,\r\n  }: {\r\n    /**\r\n     * An optional array of CoreMessage objects representing the conversation history.\r\n     * If provided, it will be used instead of the prompt.\r\n     */\r\n    messages?: CoreMessage[];\r\n  }) {\r\n    return streamText({\r\n      model: this.model,\r\n      system: await this.systemPrompt(),\r\n      tools: Object.keys(this.toolSet).length > 0 ? this.toolSet : undefined,\r\n      maxSteps: Object.keys(this.toolSet).length > 0 ? Number.MAX_SAFE_INTEGER : undefined,\r\n      messages,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Queries the AI agent with a prompt and optional session messages.\r\n   * It returns a ChatBuilder object that can be used to generate text or stream responses.\r\n   *\r\n   * @param session - An optional array of previous messages in the chat session.\r\n   * @param prompt - The user's message to start the chat.\r\n   * @param media - Optional media data to include in the chat.\r\n   * @example\r\n   * const { user, session, saveHistory } = await chatSession.useJSONFileSession({\r\n   *   folderName: \"sessions\",\r\n   *   sessionFileNameSuffix: username,\r\n   *   user: {\r\n   *     username: username,\r\n   *     phone: phone,\r\n   *   },\r\n   * })\r\n   * const chatBuilder = await agent.query({\r\n   *   session: session,\r\n   *   prompt: \"Hi there!\",\r\n   *   media: null\r\n   * });\r\n   * const textResponse = await chatBuilder.generateText();\r\n   * const streamResponse = await chatBuilder.generateStream();\r\n   * const objectResponse = await chatBuilder.generateObject(\r\n   *   z.object({\r\n   *     answer: z.string()\r\n   *   })\r\n   * );\r\n   * console.log(textResponse.text);\r\n   * console.log(streamResponse.textStream);\r\n   * console.log(objectResponse.object);\r\n   * @returns A ChatBuilder object with methods to generate text or stream responses.\r\n   * @throws Will throw an error if the prompt is not a string or if the session is not an array of CoreMessage.\r\n   */\r\n  public async query(\r\n    params : {\r\n    /**\r\n     * An optional array of previous messages in the chat session.\r\n     * This allows the AI agent to continue the conversation with the existing context.\r\n     */\r\n    session?: CoreMessage[] | null;\r\n    /**\r\n     * The user's message to start the chat.\r\n     * This should be a non-empty string representing the user's input.\r\n     */\r\n    prompt: string;\r\n    /**\r\n     * Optional media data to include in the chat.\r\n     * This can be an inline data object containing file data and mime type.\r\n     */\r\n    media?: InlineData | null;\r\n  }): Promise<ChatBuilder> {\r\n    const { session, prompt, media } = params;\r\n    try {\r\n      if (!prompt || typeof prompt !== \"string\") {\r\n        throw new Error(\"Prompt must be a non-empty string.\");\r\n      }\r\n\r\n      if (session && !Array.isArray(session)) {\r\n        throw new Error(\"Session must be an array of CoreMessage.\");\r\n      }\r\n\r\n      const messages = this.createMessages({ session, prompt, media });\r\n\r\n      return {\r\n        generateText: async () => {\r\n          return await this.generateText({ messages });\r\n        },\r\n        generateStream: async () => {\r\n          return await this.generateStream({ messages });\r\n        },\r\n        generateObject: async <OBJECT>(schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>) => {\r\n          return await this.generateObject({ messages, schema });\r\n        },\r\n      }\r\n    } catch (error) {\r\n      if (error instanceof Error && error.message.includes(\"Rate limit\")) {\r\n        Logger.warn(\"Rate limit exceeded, switching model...\");\r\n        this.model = this.initModel({\r\n          model: this.fallbackModel\r\n        });\r\n        return await this.query({ session, prompt });\r\n      }\r\n      throw new Error(`AI Agent error: ${error}`);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Starts a chat session with the AI agent.\r\n   * It initializes the conversation and returns the AI's response.\r\n   *\r\n   * @param streamMethod - The method to use for streaming responses.\r\n   * Can be \"stream\" for streaming responses or \"text\" for text responses.\r\n   * Default is \"text\".\r\n   * @param session - An optional array of previous messages in the chat session.\r\n   * This allows the AI agent to continue the conversation with the existing context.\r\n   * @param prompt - The user's message to start the chat.\r\n   * This should be a non-empty string representing the user's input.\r\n   * If the prompt is invalid or empty, an error will be thrown.\r\n   * @param media - Optional media data to include in the chat.\r\n   * This can be an inline data object containing file data and mime type.\r\n   * If not provided, the chat will not include any media.\r\n   * @returns A promise that resolves to the AI's response, which can be either a text response or a stream of text responses.\r\n   * @throws Will throw an error if the prompt is not a string or if the session is invalid.\r\n   */\r\n  public async startChat(\r\n    params : {\r\n    /**\r\n   * The method to use for streaming responses.\r\n   * Can be \"stream\" for streaming responses or \"text\" for text responses.\r\n   * Default is \"text\".\r\n   */\r\n    streamMethod?: \"text\" | \"stream\";\r\n    /**\r\n     * An optional array of previous messages in the chat session.\r\n     * This allows the AI agent to continue the conversation with the existing context.\r\n     * If not provided, a new chat session will be started.\r\n     */\r\n    session?: CoreMessage[] | null;\r\n    /**\r\n     * The user's message to start the chat.\r\n     * This should be a non-empty string representing the user's input.\r\n     * If the prompt is invalid or empty, an error will be thrown.\r\n     */\r\n    prompt: string;\r\n    /**\r\n     * Optional media data to include in the chat.\r\n     * This can be an inline data object containing file data and mime type.\r\n     * If not provided, the chat will not include any media.\r\n     */\r\n    media?: InlineData | null;\r\n  }): Promise<StartChatResult> {\r\n    const { streamMethod = \"text\", session, prompt, media } = params;\r\n    try {\r\n      if (!prompt || typeof prompt !== \"string\") {\r\n        throw new Error(\"Prompt must be a non-empty string.\");\r\n      }\r\n\r\n      if (session && !Array.isArray(session)) {\r\n        throw new Error(\"Session must be an array of CoreMessage.\");\r\n      }\r\n\r\n      this.streamMethod = streamMethod;\r\n\r\n      const messages = this.createMessages({ session, prompt, media });\r\n\r\n      return await this.getResponse(messages);\r\n    } catch (error) {\r\n      if (error instanceof Error && error.message.includes(\"Rate limit\")) {\r\n        Logger.warn(\"Rate limit exceeded, switching model...\");\r\n        this.model = this.initModel({\r\n          model: this.fallbackModel\r\n        });\r\n        return await this.startChat({ session, prompt });\r\n      }\r\n      throw new Error(`AI Agent error: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates an array of messages for the chat session.\r\n   * It includes the previous session messages and the user's prompt.\r\n   * If media is provided, it will be included in the user's message.\r\n   *\r\n   * @param session - An optional array of previous messages in the chat session.\r\n   * @param prompt - The user's message to start the chat.\r\n   * @param media - Optional media data to include in the chat.\r\n   * @returns An array of CoreMessage objects representing the chat session.\r\n   */\r\n  private createMessages({\r\n    session,\r\n    prompt,\r\n    media\r\n  }: {\r\n    /**\r\n     * An optional array of previous messages in the chat session.\r\n     * This allows the AI agent to continue the conversation with the existing context.\r\n     */\r\n    session?: CoreMessage[] | null;\r\n    /**\r\n     * The user's message to start the chat.\r\n     * This should be a non-empty string representing the user's input.\r\n     */\r\n    prompt: string;\r\n    /**\r\n     * Optional media data to include in the chat.\r\n     * This can be an inline data object containing file data and mime type.\r\n     * If not provided, the chat will not include any media.\r\n     */\r\n    media?: InlineData | null;\r\n  }): CoreMessage[] {\r\n    this.validateQueryParams({ session, prompt });\r\n\r\n    const baseMessages = session && session.length > 0 ? [...session] : [];\r\n\r\n    const userMessage: CoreMessage = !media || media.inlineData === \"\"\r\n      ? {\r\n        role: \"user\",\r\n        content: prompt,\r\n      }\r\n      : {\r\n        role: \"user\",\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: prompt,\r\n          },\r\n          {\r\n            type: \"file\",\r\n            data: media.inlineData,\r\n            mimeType: media.mimeType || \"application/octet-stream\",\r\n          },\r\n        ],\r\n      };\r\n\r\n    return [...baseMessages, userMessage];\r\n  }\r\n\r\n  /**\r\n   * Gets the AI's response based on the provided messages.\r\n   * It either generates a text response or a stream of text responses.\r\n   *\r\n   * @param messages - An array of CoreMessage objects representing the conversation history.\r\n   * @returns A promise that resolves to the AI's response, which can be either a text response or a stream of text responses.\r\n   */\r\n  private async getResponse(\r\n    /**\r\n     * An array of CoreMessage objects representing the conversation history.\r\n     * This includes the user's prompt and any previous messages in the chat session.\r\n     */\r\n    messages: CoreMessage[]\r\n  ): Promise<StartChatResult> {\r\n    if (this.streamMethod === \"stream\") {\r\n      const textStream = await this.generateStream({ messages });\r\n      return { textStream: textStream.textStream, response: textStream.response };\r\n    }\r\n\r\n    const { text, response } = await this.generateText({ messages });\r\n    return { text, response };\r\n  }\r\n\r\n  /**\r\n   * Generates text with a retry mechanism using a fallback model if the primary model fails.\r\n   * This method will attempt to generate text and, if it encounters an error related to rate limits or quota,\r\n   * it will switch to the fallback model and retry the generation.\r\n   *\r\n   * @param messages - An array of CoreMessage objects representing the conversation history.\r\n   * @param retryCount - The current retry count, defaults to 0.\r\n   * @returns A promise that resolves to the generated text or throws an error if all retries fail.\r\n   */\r\n  private async generateTextWithRetry({ messages }: { messages: CoreMessage[] }, retryCount = 0): Promise<any> {\r\n    try {\r\n      return await this.generateText({ messages });\r\n    } catch (error) {\r\n      if (this.shouldRetryWithFallback(error, retryCount)) {\r\n        Logger.warn(\"Switching to fallback model...\");\r\n        this.model = this.initModel({ model: this.fallbackModel });\r\n        return await this.generateTextWithRetry({ messages }, retryCount + 1);\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determines whether to retry with a fallback model based on the error and retry count.\r\n   * If the error is related to rate limits or quota issues, it will retry with the fallback model.\r\n   *\r\n   * @param error - The error encountered during the request.\r\n   * @param retryCount - The current retry count.\r\n   * @returns A boolean indicating whether to retry with the fallback model.\r\n   */\r\n  private shouldRetryWithFallback(error: unknown, retryCount: number): boolean {\r\n    const MAX_RETRY = 1;\r\n    return retryCount < MAX_RETRY &&\r\n      !!this.fallbackModel &&\r\n      error instanceof Error &&\r\n      (error.message.includes(\"Rate limit\") || error.message.includes(\"quota\"));\r\n  }\r\n}\r\n","import * as crypto from \"crypto\";\r\nimport * as path from \"path\";\r\nimport * as fs from \"fs\";\r\nimport chokidar, { FSWatcherKnownEventMap } from \"chokidar\";\r\nimport { mimeType } from \"@/utils/mimeType\";\r\nimport { FileDownloadInterface, FileInterface, FileStorageInterface } from \"@/types\";\r\n\r\n/**\r\n * IOF (Input/Output File) class provides methods for file and directory operations,\r\n * including creating directories, removing files, watching directories for changes,\r\n * reading and writing JSON files, calculating file hashes and sizes, and saving files.\r\n */\r\nexport class IOF {\r\n\r\n  /**\r\n   * Creates a directory if it does not exist.\r\n   * @param dirPath - The path of the directory to create.\r\n   */\r\n  public static mkdir(dirPath: string): void {\r\n    try {\r\n      if (!fs.existsSync(dirPath)) {\r\n        fs.mkdirSync(dirPath, { recursive: true });\r\n      }\r\n    } catch (error) {\r\n      throw new Error(`Failed to create directory at ${dirPath}:  ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a directory or file at the specified path.\r\n   * If the path is a directory, it will be removed recursively.\r\n   * @param dirPath - The path of the directory to remove.\r\n   */\r\n  public static rm(dirPath: string): void {\r\n    try {\r\n      if (fs.existsSync(dirPath)) {\r\n        fs.rmSync(dirPath, { recursive: true, force: true });\r\n      }\r\n    } catch (error) {\r\n      throw new Error(`Failed to remove at ${dirPath}: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Watches a directory for file system events and executes a callback with the event details.\r\n   * @param options - The options for the watcher.\r\n   * @param options.dirPath - The path of the directory to watch.\r\n   * @param options.event - The type of event to listen for (e.g., \"add\", \"change\", \"unlink\").\r\n   * @param options.onEvent - Optional callback function to handle file system events.\r\n   * \r\n   */\r\n  public static watcher(\r\n    options: {\r\n      /**\r\n       * The path of the directory to watch.\r\n       */\r\n      dirPath: string;\r\n      /**\r\n       * The type of event to listen for.\r\n       */\r\n      event: keyof FSWatcherKnownEventMap | \"add\" | \"change\" | \"addDir\" | \"unlink\" | \"unlinkDir\";\r\n      /**\r\n       * Optional callback function to handle file system events.\r\n       */\r\n      onEvent?: (\r\n        args: {\r\n          /**\r\n           * The full path of the file that triggered the event.\r\n           */\r\n          filePath: string;\r\n          /**\r\n           * The type of event that occurred.\r\n           */\r\n          event: keyof FSWatcherKnownEventMap | \"add\" | \"change\" | \"addDir\" | \"unlink\" | \"unlinkDir\";\r\n        }\r\n      ) => Promise<void>;\r\n    }\r\n  ) {\r\n    const { dirPath, event, onEvent } = options;\r\n    const fullPath = path.resolve(process.cwd(), dirPath);\r\n    const watcher = chokidar.watch(fullPath, { persistent: true });\r\n    watcher.on(event, async (filePath: string) => {\r\n      if (onEvent) {\r\n        await onEvent({\r\n          filePath: path.resolve(process.cwd(), filePath),\r\n          event,\r\n        });\r\n      }\r\n    });\r\n    watcher.on(\"error\", async (error) => {\r\n      throw new Error(`Watcher error: ${error instanceof Error ? error.message : String(error)}`);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Checks if a file exists at the specified path.\r\n   * @param filePath - The path to the file.\r\n   * @returns A boolean indicating whether the file exists.\r\n   * @throws An error if the existence check fails.\r\n   */\r\n  public static existsFileSync(filePath: string): boolean {\r\n    try {\r\n      return fs.existsSync(filePath);\r\n    } catch (error) {\r\n      throw new Error(`Failed to check existence of ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Asynchronously checks if a file exists at the specified path.\r\n   * @param filePath - The path to the file.\r\n   * @returns A promise that resolves to a boolean indicating whether the file exists.\r\n   * @throws An error if the existence check fails.\r\n   */\r\n  public static async existsFile(filePath: string): Promise<boolean> {\r\n    try {\r\n      return await fs.promises.access(filePath, fs.constants.F_OK).then(() => true).catch(() => false);\r\n    } catch (error) {\r\n      throw new Error(`Failed to check existence of ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Writes an object to a JSON file, appending it to an existing array if the file already exists.\r\n   * @param filePath - The path to the JSON file.\r\n   * @param data - The object to write to the file.\r\n   * @throws An error if the file cannot be written or if the content is not an array.\r\n   */\r\n  public static async writeJSONFile<T>(params: { filePath: string; data: T }): Promise<void> {\r\n    const { filePath, data } = params;\r\n    try {\r\n      if (!IOF.existsFileSync(path.dirname(filePath))) {\r\n        IOF.mkdir(path.dirname(filePath));\r\n      }\r\n      let arrayData: T[] = [];\r\n      if (fs.existsSync(filePath)) {\r\n        const jsonData = await fs.promises.readFile(filePath, \"utf-8\");\r\n        arrayData = JSON.parse(jsonData);\r\n        if (!Array.isArray(arrayData)) arrayData = [];\r\n      }\r\n      arrayData.push(data);\r\n      const newJsonData = JSON.stringify(arrayData, null, 2);\r\n      fs.writeFileSync(filePath, newJsonData);\r\n    } catch (error) {\r\n      throw new Error(`Failed to write JSON to ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Overwrites a JSON file with a new array of objects.\r\n   * @param filePath - The path to the JSON file.\r\n   * @param data - The array of objects to write to the file.\r\n   * @throws An error if the file cannot be written or if the content is not an array.\r\n   */\r\n  public static async writeJSONFileOverwrite<T>(params: { filePath: string; data: T[] }): Promise<void> {\r\n    const { filePath, data } = params;\r\n    try {\r\n      if (!fs.existsSync(path.dirname(filePath))) {\r\n        IOF.mkdir(path.dirname(filePath));\r\n      }\r\n      const newJsonData = JSON.stringify(data, null, 2);\r\n      await fs.promises.writeFile(filePath, newJsonData);\r\n    } catch (error) {\r\n      throw new Error(`Failed to overwrite JSON to ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reads a JSON file and returns its content as an array.\r\n   * @param filePath - The path to the JSON file.\r\n   * @returns An array of objects parsed from the JSON file.\r\n   * @throws An error if the file does not exist or if the content is not an array.\r\n   */\r\n  public static async readJSONFile<T>(filePath: string): Promise<T[]> {\r\n    try {\r\n      if (!fs.existsSync(filePath)) {\r\n        throw new Error(`File not found: ${filePath}`);\r\n      }\r\n      const jsonData = await fs.promises.readFile(filePath, \"utf-8\");\r\n      const arr = JSON.parse(jsonData);\r\n      if (!Array.isArray(arr)) {\r\n        throw new Error(`File content is not an array: ${filePath}`);\r\n      }\r\n      return arr as T[];\r\n    } catch (error) {\r\n      throw new Error(`Failed to read JSON from ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates the SHA-256 hash of a given buffer.\r\n   * @param buffer - The buffer to hash.\r\n   * @returns The SHA-256 hash as a hexadecimal string.\r\n   */\r\n  public static calculateHashByBuffer(buffer: Buffer): string {\r\n    if (!Buffer.isBuffer(buffer)) {\r\n      throw new Error(\"Input must be a Buffer\");\r\n    }\r\n    if (buffer.length === 0) {\r\n      throw new Error(\"Buffer cannot be empty\");\r\n    }\r\n    return crypto.createHash(\"sha256\").update(buffer).digest(\"hex\");\r\n  }\r\n\r\n  /**\r\n   * Calculates the size of a file based on its buffer.\r\n   * @param buffer - The buffer representing the file.\r\n   * @returns The size of the file in bytes.\r\n   */\r\n  public static calculateSizeByBuffer(buffer: Buffer): number {\r\n    if (!Buffer.isBuffer(buffer)) {\r\n      throw new Error(\"Input must be a Buffer\");\r\n    }\r\n    if (buffer.length === 0) {\r\n      throw new Error(\"Buffer cannot be empty\");\r\n    }\r\n    return Buffer.byteLength(buffer);\r\n  }\r\n\r\n\r\n  /**\r\n   * Saves a file buffer to the specified file path on disk.\r\n   *\r\n   * Calculates the file's hash, size, and MIME type, creates the necessary directories,\r\n   * and writes the file data to disk. Returns an object containing metadata about the saved file.\r\n   *\r\n   * @param data - An object implementing the FileInterface, containing the file data, filename, and target filepath.\r\n   * @returns A promise that resolves to a FileStorageInterface object with file metadata, or null if saving fails.\r\n   * @throws {Error} If the file cannot be saved to the specified location.\r\n   */\r\n  public async saveBufferToFile(data: FileInterface): Promise<FileStorageInterface | null> {\r\n    const hash = IOF.calculateHashByBuffer(Buffer.from(data.filedata));\r\n    const size = IOF.calculateSizeByBuffer(Buffer.from(data.filedata));\r\n    const type = mimeType(data.filename);\r\n\r\n    try {\r\n      const fullPath = path.resolve(process.cwd(), data.filepath, data.filename);\r\n      const dir = path.dirname(fullPath);\r\n      IOF.mkdir(dir);\r\n      await fs.promises.writeFile(fullPath, data.filedata);\r\n\r\n      return {\r\n        filename: data.filename,\r\n        fileuri: fullPath,\r\n        filehash: hash,\r\n        filesize: size,\r\n        mimeType: type,\r\n        inlineData: Buffer.from(data.filedata).toString(\"base64\"),\r\n      };\r\n    } catch (error) {\r\n      throw new Error(`Failed to set file location: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Downloads a file from a given URL and saves it to the specified download path.\r\n   * @param data - The file download data including the file URL and save path.\r\n   * @returns The metadata of the downloaded file.\r\n   */\r\n  public static async downloadFile(data: FileDownloadInterface): Promise<FileStorageInterface> {\r\n    try {\r\n      const response = await fetch(data.fileuri);\r\n      const buffer = await response.arrayBuffer();\r\n      const fileName = path.basename(data.fileuri);\r\n      const filePath = path.join(data.saveTo, fileName);\r\n      fs.writeFileSync(filePath, Buffer.from(buffer));\r\n      return {\r\n        filename: fileName,\r\n        fileuri: filePath,\r\n        filehash: IOF.calculateHashByBuffer(Buffer.from(buffer)),\r\n        filesize: IOF.calculateSizeByBuffer(Buffer.from(buffer)),\r\n        mimeType: mimeType(fileName),\r\n        inlineData: Buffer.from(buffer).toString(\"base64\"),\r\n      };\r\n    } catch (error) {\r\n      throw new Error(`Failed to download file: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves the string content of a text file.\r\n   * @param filePath - The path to the text file.\r\n   * @returns A promise that resolves to the content of the file as a string.\r\n   * @throws An error if the file cannot be read.\r\n   */\r\n  public static async readTextFile(filePath: string): Promise<string> {\r\n    try {\r\n      const data = await fs.promises.readFile(filePath, \"utf-8\");\r\n      return data;\r\n    } catch (error) {\r\n      throw new Error(`Failed to read file at ${filePath}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts a file to a generative path format.\r\n   * @param fileName - The name of the file to convert.\r\n   * @returns An object containing the inline data with base64 encoded content and MIME type.\r\n   * @throws An error if the file cannot be read or converted.\r\n   */\r\n  public async fileToGenerativePath(fileName: string) {\r\n    try {\r\n      const mime = mimeType(fileName);\r\n      const file = await fs.promises.readFile(fileName);\r\n      return {\r\n        inlineData: {\r\n          data: Buffer.from(file).toString(\"base64\"),\r\n          mimeType: mime,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      throw new Error(`Failed to convert file to generative path: ${error}`);\r\n    }\r\n  }\r\n}\r\n","export function mimeType(fileName: string) {\r\n    const ext = fileName.split(\".\").pop();\r\n    switch (ext) {\r\n      // video\r\n      case \"mp4\":\r\n        return \"video/mp4\";\r\n      case \"mpeg\":\r\n      case \"mpg\":\r\n      case \"mpe\":\r\n      case \"mpv\":\r\n      case \"mp2\":\r\n      case \"m2v\":\r\n      case \"m2ts\":\r\n      case \"mts\":\r\n      case \"tts\":\r\n      case \"m2t\":\r\n      case \"tsv\":\r\n      case \"tsa\":\r\n        return \"video/mpeg\";\r\n      case \"webm\":\r\n        return \"video/webm\";\r\n      case \"3gp\":\r\n        return \"video/3gpp\";\r\n      case \"mkv\":\r\n        return \"video/x-matroska\";\r\n      case \"avi\":\r\n        return \"video/x-msvideo\";\r\n      case \"mov\":\r\n        return \"video/quicktime\";\r\n      case \"wmv\":\r\n        return \"video/x-ms-wmv\";\r\n      case \"flv\":\r\n        return \"video/x-flv\";\r\n      case \"m4v\":\r\n        return \"video/x-m4v\";\r\n  \r\n      //  audio\r\n      case \"mp3\":\r\n        return \"audio/mpeg\";\r\n      case \"m4a\":\r\n        return \"audio/mp4\";\r\n      case \"m4b\":\r\n      case \"m4p\":\r\n      case \"m4r\":\r\n        return \"audio/mp4\";\r\n      case \"wav\":\r\n        return \"audio/wav\";\r\n      case \"ogg\":\r\n        return \"audio/ogg\";\r\n      case \"aac\":\r\n        return \"audio/aac\";\r\n      case \"flac\":\r\n        return \"audio/flac\";\r\n      case \"alac\":\r\n        return \"audio/alac\";\r\n  \r\n      // image\r\n      case \"jpg\":\r\n      case \"jpeg\":\r\n        return \"image/jpeg\";\r\n      case \"png\":\r\n        return \"image/png\";\r\n      case \"gif\":\r\n        return \"image/gif\";\r\n      case \"bmp\":\r\n        return \"image/bmp\";\r\n      case \"webp\":\r\n        return \"image/webp\";\r\n      case \"svg\":\r\n        return \"image/svg+xml\";\r\n      case \"ico\":\r\n        return \"image/x-icon\";\r\n      case \"tiff\":\r\n        return \"image/tiff\";\r\n      case \"psd\":\r\n        return \"image/vnd.adobe.photoshop\";\r\n      case \"ai\":\r\n        return \"application/postscript\";\r\n      case \"eps\":\r\n        return \"application/postscript\";\r\n      case \"indd\":\r\n        return \"application/x-indesign\";\r\n      case \"raw\":\r\n        return \"image/x-raw\";\r\n      case \"cr2\":\r\n        return \"image/x-canon-cr2\";\r\n      case \"nef\":\r\n        return \"image/x-nikon-nef\";\r\n      case \"orf\":\r\n        return \"image/x-olympus-orf\";\r\n      case \"rw2\":\r\n        return \"image/x-panasonic-rw2\";\r\n      case \"pef\":\r\n        return \"image/x-pentax-pef\";\r\n      case \"arw\":\r\n        return \"image/x-sony-arw\";\r\n      case \"dng\":\r\n        return \"image/x-adobe-dng\";\r\n      case \"x3f\":\r\n        return \"image/x-sigma-x3f\";\r\n      case \"cr3\":\r\n        return \"image/x-canon-cr3\";\r\n      case \"heic\":\r\n        return \"image/heic\";\r\n      case \"heif\":\r\n        return \"image/heif\";\r\n      case \"avif\":\r\n        return \"image/avif\";\r\n  \r\n      // application\r\n      case \"pdf\":\r\n        return \"application/pdf\";\r\n      case \"txt\":\r\n        return \"text/plain\";\r\n  \r\n      // text\r\n      case \"html\":\r\n        return \"text/html\";\r\n      case \"css\":\r\n        return \"text/css\";\r\n      case \"js\":\r\n        return \"application/javascript\";\r\n      case \"json\":\r\n        return \"application/json\";\r\n      case \"xml\":\r\n        return \"application/xml\";\r\n  \r\n      // archive\r\n      case \"zip\":\r\n        return \"application/zip\";\r\n      case \"rar\":\r\n        return \"application/x-rar-compressed\";\r\n      case \"7z\":\r\n        return \"application/x-7z-compressed\";\r\n      default:\r\n        return \"application/octet-stream\";\r\n    }\r\n  }","import { Time } from \"@/utils/time\";\r\nimport { tool } from \"ai\";\r\nimport { z } from \"zod\";\r\n\r\nexport const TaskHandler = {\r\n    /**\r\n     * Get the current date and time in real-time.\r\n     * This tool does not require any parameters. It returns the current time in a standard format.\r\n     */\r\n    getCurrentTime: tool({\r\n        description: \"Get the current date and time in real-time. This tool does not require any parameters. It returns the current time in a standard format. Use this tool when user ask you for current time or date or anything that related to time.\",\r\n        parameters: z.object({}),\r\n        execute: async () => await Tools.getCurrentTime(),\r\n    }),\r\n}\r\n\r\n\r\nexport class Tools {\r\n\r\n    /**\r\n     * Retrieves the current time in a human-readable format.\r\n     * This tool does not require any parameters.\r\n     */\r\n    public static async getCurrentTime() {\r\n        return Time.getCurrentTimeToHumanReadable()\r\n    }\r\n}","import crypto, { randomUUID } from \"crypto\";\r\n\r\n\r\nexport function HashWithSHA256(data: string): string {\r\n  return crypto.createHash(\"sha256\").update(data).digest(\"hex\");\r\n}\r\n\r\nexport function GenerateUUID(): string {\r\n  return randomUUID();\r\n}\r\n\r\nexport function GenerateRandomString(length: number): string {\r\n  return crypto.randomBytes(length).toString(\"hex\").slice(0, length);\r\n}","import * as rl from \"node:readline/promises\";\r\nimport dotenv from \"dotenv\";\r\ndotenv.config();\r\n\r\nconst terminal = rl.createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout,\r\n  terminal: true,\r\n  completer: (line) => {\r\n    const completions = [\"help\", \"exit\", \"clear\"];\r\n    const hits = completions.filter((c) => c.startsWith(line));\r\n    return [hits.length ? hits : completions, line];\r\n  },\r\n});\r\n\r\n/**\r\n * Prompts the user for input and returns the response.\r\n * @param question The question to ask the user.\r\n * @returns A promise that resolves to the user's input.\r\n */\r\nexport async function Question(question?: string): Promise<string> {\r\n  return terminal.question(question ? question + \": \" : \": \");\r\n}\r\n\r\n/**\r\n * Closes the terminal interface and exits the process.\r\n * This function is useful for gracefully shutting down the terminal.\r\n */\r\nexport async function CloseTerminal() {\r\n  await terminal.close();\r\n  process.exit(0);\r\n}\r\n\r\n/**\r\n * Clears the terminal screen.\r\n * @returns A promise that resolves to the user's input.\r\n */\r\nexport async function ClearTerminal() {\r\n  process.stdout.write(\"\\x1Bc\");\r\n  return terminal.prompt();\r\n}\r\n\r\n/**\r\n * Pauses execution for a specified duration (in seconds), similar to Python's sleep.\r\n * @param duration The number of seconds to sleep.\r\n * @returns A promise that resolves after the specified duration.\r\n */\r\nexport async function Sleep(duration: number): Promise<void> {\r\n  return new Promise((resolve) => setTimeout(resolve, duration * 1000));\r\n}\r\n\r\n/**\r\n * This function filters environment variables that start with the specified prefix,\r\n * Parses environment variables that start with a given prefix.\r\n * @param prefix The prefix to filter environment variables.\r\n * @returns An object containing arrays of keys and values.\r\n * @example\r\n * const envVars = ParseEnvKeys(\"AI_TOKEN_\");\r\n * console.log(envVars.keys); // ['AI_TOKEN_KEY']\r\n * console.log(envVars.values); // ['your_token_value']\r\n */\r\nexport function ParseEnvKeys(prefix: string): { keys: string[]; values: string[] } {\r\n  const envKeys = Object.keys(process.env).filter((key) =>\r\n    key.startsWith(prefix)\r\n  );\r\n  const keys: string[] = [];\r\n  const values: string[] = [];\r\n\r\n  envKeys.forEach((key) => {\r\n    if (process.env[key]) {\r\n      keys.push(key);\r\n      values.push(process.env[key]!);\r\n    }\r\n  });\r\n\r\n  return { keys, values };\r\n}\r\n","import { ConversationDB, SessionResult, UserBase } from \"@/types\";\r\nimport { IOF } from \"@/lib/iof\";\r\nimport { CoreMessage } from \"ai\";\r\nimport { Time } from \"@/utils/time\";\r\n\r\ninterface SessionConfig {\r\n    /**\r\n     * The platform for the session, e.g., \"web\", \"mobile\", etc.\r\n     */\r\n    platform: string;\r\n}\r\n\r\n/**\r\n * Represents a session for an AI agent.\r\n * This class is used to manage the session configuration and operations.\r\n * It can be extended to implement specific session functionalities.\r\n * @example\r\n * const session = new AgentSession({\r\n *   platform: \"web\",\r\n * });\r\n * \r\n */\r\nexport class AgentSession {\r\n    private platform: string;\r\n    private folderName: string = \"sessions\";\r\n    private sessionFilePrefix: string = \"session-\";\r\n    private userBase: UserBase | null = null;\r\n    private userSessionFileName: string | null = null;\r\n    private sessionFileName: string | null = null\r\n\r\n    private memorySession: Record<string, CoreMessage[]> = {};\r\n\r\n    /**\r\n     * Creates a new session with the specified configuration.\r\n     * @param config - The configuration for the session, including the platform.\r\n     */\r\n    constructor(config: SessionConfig) {\r\n        this.platform = config.platform;\r\n        this.initPlatform().catch(error => {\r\n            throw new Error(error);\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Initializes the platform for the session.\r\n     * This method can be overridden to implement platform-specific initialization logic.\r\n     */\r\n    private async initPlatform() {\r\n        try {\r\n            const platform = this.platform;\r\n\r\n            if (!platform) {\r\n                throw new Error(\"Platform is required to initialize the session.\");\r\n            }\r\n            if (!await IOF.existsFile(`./${this.folderName}/platform.json`)) {\r\n                IOF.writeJSONFileOverwrite<{\r\n                    platform: string;\r\n                    createdAt: Date;\r\n                }>({\r\n                    filePath: `./${this.folderName}/platform.json`,\r\n                    data: [{ platform, createdAt: Time.getCurrentTime() }]\r\n                });\r\n            }\r\n        } catch (error) {\r\n            throw new Error(`Failed to initialize platform: ${error instanceof Error ? error.message : String(error)}`);\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts a new session for the user using in-memory storage.\r\n     * This method is useful for quick sessions that do not require persistent storage.\r\n     * @param user - The user for whom the session is being started.\r\n     * @example\r\n     * const agentSession = new AgentSession({\r\n     *   platform: \"test\",\r\n     * });\r\n     * const { user, session, saveHistory } = await agentSession.useMemorySession({\r\n     *   user: {\r\n     *     username: \"testuser\",\r\n     *     email: \"testuser@example.com\"\r\n     *   }\r\n     * });\r\n     * const userMessage = await Question(\"[You]\");\r\n     * await saveHistory<string>({\r\n     *   role: \"user\",\r\n     *   text: userMessage,\r\n     *   timestamp: Time.getCurrentTime(),\r\n     * });\r\n     * @returns An object containing the user and the session history.\r\n     */\r\n    public async useMemorySession({\r\n        user,\r\n    }: {\r\n        /**\r\n         * The user for whom the session is being started.\r\n         * This is required to create or resume a session.\r\n         */\r\n        user: UserBase;\r\n    }): Promise<SessionResult> {\r\n        const sessionKey = user.phone || user.email || user.username || user.name || \"unknown\";\r\n        this.userBase = user;\r\n\r\n        if (!this.memorySession[sessionKey]) {\r\n            this.memorySession[sessionKey] = [];\r\n        }\r\n\r\n        return {\r\n            user: this.userBase,\r\n            session: this.memorySession[sessionKey],\r\n            saveHistory: async <T>(data: ConversationDB<T>) => {\r\n                let coreMsg: CoreMessage;\r\n                if (\"text\" in data && typeof data.text === \"string\") {\r\n                    coreMsg = {\r\n                        role: data.role,\r\n                        content: [\r\n                            {\r\n                                type: \"text\",\r\n                                text: data.text,\r\n                            },\r\n                        ],\r\n                    };\r\n                } else if (\"content\" in data) {\r\n                    coreMsg = {\r\n                        role: data.role,\r\n                        content: [\r\n                            {\r\n                                type: \"text\",\r\n                                text: typeof data.content === \"string\"\r\n                                    ? data.content\r\n                                    : JSON.stringify(data.content, null, 2),\r\n                            },\r\n                        ],\r\n                    };\r\n                } else {\r\n                    throw new Error(\"Invalid data format for saveHistory.\");\r\n                }\r\n                this.memorySession[sessionKey].push(coreMsg);\r\n                return this.memorySession[sessionKey];\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Starts a new session for the user.\r\n     * If the session file does not exist, it creates a new one.\r\n     * If it exists, it resumes the session from the file.\r\n     * @param user - The user for whom the session is being started.\r\n     * @param folderName - The name of the folder where session files are stored.\r\n     * @param sessionFileNameSuffix - The name of the session file. If not provided, it defaults to a combination of the sessionFilePrefix and the user's username, email, phone, or name.\r\n     * @returns An object containing the user and the session history.\r\n     * @throws An error if the user is not provided or if the session file cannot be created or resumed.\r\n     * @example\r\n     * const agentSession = new AgentSession({\r\n     *   platform: \"test\",\r\n     * });\r\n     * const { user, session, saveHistory } = await agentSession.useJSONFileSession({\r\n     *   folderName: \"sessions\",\r\n     *   sessionFileNameSuffix: \"testuser\",\r\n     *   user: {\r\n     *     username: \"testuser\",\r\n     *     email: \"testuser@example.com\"\r\n     *   }\r\n     * });\r\n     *\r\n     * const userMessage = await Question(\"[You]\");\r\n     * await saveHistory<string>({\r\n     *   role: \"user\",\r\n     *   text: userMessage,\r\n     *   timestamp: Time.getCurrentTime(),\r\n     * });\r\n     */\r\n    public async useJSONFileSession(\r\n        params : {\r\n        /**\r\n         * The name of the folder where session files are stored.\r\n         * This is required to create or resume a session.\r\n         */\r\n        folderName: string;\r\n        /**\r\n         * The user for whom the session is being started.\r\n         * This is required to create or resume a session.\r\n         */\r\n        user: UserBase;\r\n        /**\r\n         * The name of the session file. If not provided, it defaults to a combination of the sessionFilePrefix and the user's username, email, phone, or name.\r\n         */\r\n        sessionFileNameSuffix?: string;\r\n    }): Promise<SessionResult> {\r\n        const { folderName, user, sessionFileNameSuffix } = params;\r\n\r\n        if (!user) {\r\n            throw new Error(\"User is required to start a session.\");\r\n        }\r\n        if (!sessionFileNameSuffix) {\r\n            this.sessionFileName = `./${this.folderName}/${this.sessionFilePrefix}${user.username || user.email || user.phone || user.name}.json`;\r\n        } else if (sessionFileNameSuffix.includes('/')) {\r\n            this.sessionFileName = sessionFileNameSuffix;\r\n        } else {\r\n            this.sessionFileName = `./${this.folderName}/${this.sessionFilePrefix}${sessionFileNameSuffix}.json`;\r\n        }\r\n        this.folderName = folderName || this.folderName;\r\n        this.userBase = user;\r\n        IOF.mkdir(`./${this.folderName}`);\r\n        const session = await this.resumeJSONFileSession({\r\n            user,\r\n            fileName: this.sessionFileName\r\n        });\r\n        if (session && session.session.length > 0) {\r\n            return {\r\n                user: session.user,\r\n                session: session.session,\r\n                saveHistory: async <T>(data: ConversationDB<T>) => {\r\n                    return this.saveHistory<T>(data);\r\n                }\r\n            }\r\n        }\r\n        const createdNewSession = await this.createNewJSONFileSession({ user, fileName: this.sessionFileName });\r\n        return {\r\n            user: createdNewSession.user,\r\n            session: createdNewSession.session,\r\n            saveHistory: async <T>(data: ConversationDB<T>) => {\r\n                return this.saveHistory<T>(data);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves the conversation history to a JSON file.\r\n     * @param data - The conversation data to be saved.\r\n     * @throws An error if the file cannot be written or if the content is not an array.\r\n     */\r\n    private async saveHistory<T>(data: ConversationDB<T>) {\r\n        if (!this.userBase) {\r\n            throw new Error(\"User must be set before saving history.\");\r\n        }\r\n        const filePath = this.sessionFileName || `./${this.folderName}/${this.sessionFilePrefix}${this.userBase?.username || this.userBase?.email || this.userBase?.phone || this.userBase?.name}.json`;\r\n        await IOF.writeJSONFile({\r\n            filePath: filePath,\r\n            data: data\r\n        });\r\n        return await this.getHistory(filePath);\r\n    }\r\n\r\n    /**\r\n     * Retrieves user data from a JSON file.\r\n     * If the user exists, it returns the user data; otherwise, it returns null.\r\n     * @param user - The user object containing the phone number to search for.\r\n     * @returns The user data if found, or null if not found.\r\n     */\r\n    public async getUserData(user: UserBase): Promise<UserBase | null> {\r\n        const usersFilePath = this.userSessionFileName || `./${this.folderName}/users.json`;\r\n        if (await IOF.existsFile(usersFilePath)) {\r\n            const history = await IOF.readJSONFile<UserBase>(usersFilePath);\r\n            const existingUser = history.find(u => u.phone === user.phone);\r\n            if (existingUser) {\r\n                return existingUser;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n    * Retrieves the conversation history from a JSON file.\r\n    * The history is sorted by message timestamp and response timestamp.\r\n    * @param filePath - The path to the JSON file containing the conversation history.\r\n    * @returns An array of CoreMessage objects representing the conversation history.\r\n    */\r\n    public async getHistory(filePath: string) {\r\n        const history = await IOF.readJSONFile<ConversationDB<any>>(filePath)\r\n        if (!history || history.length === 0) {\r\n            return [];\r\n        }\r\n        history?.sort((a, b) => {\r\n            // Compare by messageTimestamp first (ascending order)\r\n            const messageTimestampComparison =\r\n                new Date(a.timestamp).getTime() -\r\n                new Date(b.timestamp).getTime();\r\n            if (messageTimestampComparison !== 0) {\r\n                return messageTimestampComparison;\r\n            }\r\n\r\n            // If messageTimestamp timestamps are equal, compare by responseTimestamp (ascending order)\r\n            const responseTimestampComparison =\r\n                new Date(a.timestamp || 0).getTime() -\r\n                new Date(b.timestamp || 0).getTime();\r\n            return responseTimestampComparison;\r\n        });\r\n\r\n        const message: CoreMessage[] = [];\r\n        history.forEach((item) => {\r\n            if ('text' in item && item.role === \"user\" && typeof item.text === \"string\") {\r\n                message.push({\r\n                    role: item.role,\r\n                    content: [\r\n                        {\r\n                            type: \"text\",\r\n                            text: item.text,\r\n                        },\r\n                    ],\r\n                });\r\n            } else if ('text' in item && item.role === \"assistant\" && typeof item.text === \"string\") {\r\n                message.push({\r\n                    role: item.role,\r\n                    content: [\r\n                        {\r\n                            type: \"text\",\r\n                            text: item.text,\r\n                        },\r\n                    ],\r\n                });\r\n            } else if ('content' in item && item.role === \"assistant\") {\r\n                let processedContent;\r\n\r\n                if (Array.isArray(item.content)) {\r\n                    processedContent = item.content.map((contentItem: any) => {\r\n                        if (typeof contentItem === \"string\") {\r\n                            return {\r\n                                type: \"text\",\r\n                                text: contentItem\r\n                            };\r\n                        }\r\n                        return contentItem;\r\n                    });\r\n                } else if (typeof item.content === 'object' && item.content !== null) {\r\n                    processedContent = [{\r\n                        type: \"text\",\r\n                        text: JSON.stringify(item.content, null, 2)\r\n                    }];\r\n                } else {\r\n                    processedContent = [{\r\n                        type: \"text\",\r\n                        text: String(item.content)\r\n                    }];\r\n                }\r\n\r\n                message.push({\r\n                    role: item.role,\r\n                    content: processedContent\r\n                });\r\n            }\r\n        });\r\n\r\n        return message;\r\n    }\r\n\r\n\r\n    /**\r\n     * Starts a new session for the user.\r\n     * If the session file does not exist, it creates a new one.\r\n     * If it exists, it resumes the session from the file.\r\n     * @param user - The user for whom the session is being started.\r\n     * @returns An object containing the user and the session history.\r\n     */\r\n    private async createUserJSONFileSession(user: UserBase) {\r\n        if (!user) {\r\n            throw new Error(\"User is required to create a session.\");\r\n        }\r\n        const usersFilePath = `./${this.folderName}/users.json`;\r\n        this.userSessionFileName = usersFilePath;\r\n        // Ensure the users file exists and read existing users\r\n        IOF.mkdir(`./${this.folderName}`);\r\n\r\n        let users: UserBase[] = [];\r\n        if (IOF.existsFileSync(usersFilePath)) {\r\n            users = await IOF.readJSONFile<UserBase>(usersFilePath);\r\n            const existingUser = users.find(u => u.username === user.username || u.email === user.email || u.phone === user.phone || u.name === user.name);\r\n            if (existingUser) {\r\n                return existingUser;\r\n            }\r\n            users.push(user);\r\n            await IOF.writeJSONFileOverwrite({\r\n                filePath: usersFilePath,\r\n                data: users\r\n            });\r\n            return user;\r\n        } else {\r\n            await IOF.writeJSONFileOverwrite({\r\n                filePath: usersFilePath,\r\n                data: [user]\r\n            });\r\n            return user;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts a new session for the user.\r\n     * If the session file does not exist, it creates a new one.\r\n     * If it exists, it resumes the session from the file.\r\n     * @param user - The user for whom the session is being started.\r\n     * @returns An object containing the user and the session history.\r\n     */\r\n    private async createNewJSONFileSession({ user, fileName }: { user: UserBase; fileName?: string; }) {\r\n        try {\r\n            if (!user) {\r\n                throw new Error(\"User is required to create a session.\");\r\n            }\r\n            const userSession = await this.createUserJSONFileSession(user);\r\n            const targetFilePath = this.sessionFileName ||\r\n                `./${this.folderName}/${this.sessionFilePrefix}${user.username || user.email || user.phone || user.name}.json`;\r\n\r\n            await IOF.writeJSONFileOverwrite({ filePath: targetFilePath, data: [] as CoreMessage[] });\r\n            return {\r\n                user: userSession,\r\n                session: [] as CoreMessage[]\r\n            }\r\n        } catch (error) {\r\n            throw new Error(`Failed to create new session for user ${user.username || user.email || user.phone || user.name}: ${error instanceof Error ? error.message : String(error)}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resumes the session from a JSON file.\r\n     * If the file does not exist or is empty, it returns an empty array.\r\n     * @param user - The user for whom the session is being resumed.\r\n     * @returns An array of CoreMessages from the JSON file.\r\n     */\r\n    private async resumeJSONFileSession({ user, fileName }: { user: UserBase; fileName?: string; }): Promise<{ user: UserBase; session: CoreMessage[] }> {\r\n        try {\r\n            const history = await this.getHistory(fileName ||\r\n                `./${this.folderName}/${this.sessionFilePrefix}${user.username || user.email || user.phone || user.name}.json`);\r\n            return {\r\n                user: user,\r\n                session: history\r\n            };\r\n        } catch (error) {\r\n            if (error instanceof Error && error.message.includes(\"File not found\")) {\r\n                return {\r\n                    user: user,\r\n                    session: []\r\n                };\r\n            }\r\n            throw new Error(`Failed to resume session for user ${user.username || user.email || user.phone || user.name}: ${error instanceof Error ? error.message : String(error)}`);\r\n        }\r\n    }\r\n}"],"mappings":"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K;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA;AAAA,IAGT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA;AAAA,IAGT,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA;AAAA,IAGT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA;AAAA,IAGT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA;AAAA,IAGT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;;;AD7HK,IAAM,MAAN,MAAM,KAAI;AAAA;AAAA;AAAA;AAAA;AAAA,EAMf,OAAc,MAAM,SAAuB;AACzC,QAAI;AACF,UAAI,CAAI,cAAW,OAAO,GAAG;AAC3B,QAAG,aAAU,SAAS,EAAE,WAAW,KAAK,CAAC;AAAA,MAC3C;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,iCAAiC,OAAO,MAAM,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,IACxH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAc,GAAG,SAAuB;AACtC,QAAI;AACF,UAAO,cAAW,OAAO,GAAG;AAC1B,QAAG,UAAO,SAAS,EAAE,WAAW,MAAM,OAAO,KAAK,CAAC;AAAA,MACrD;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,uBAAuB,OAAO,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,IAC7G;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,OAAc,QACZ,SAyBA;AACA,UAAM,EAAE,SAAS,OAAO,QAAQ,IAAI;AACpC,UAAM,WAAgB,aAAQ,QAAQ,IAAI,GAAG,OAAO;AACpD,UAAM,UAAU,gBAAAC,QAAS,MAAM,UAAU,EAAE,YAAY,KAAK,CAAC;AAC7D,YAAQ,GAAG,OAAO,OAAO,aAAqB;AAC5C,UAAI,SAAS;AACX,cAAM,QAAQ;AAAA,UACZ,UAAe,aAAQ,QAAQ,IAAI,GAAG,QAAQ;AAAA,UAC9C;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AACD,YAAQ,GAAG,SAAS,OAAO,UAAU;AACnC,YAAM,IAAI,MAAM,kBAAkB,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,IAC5F,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAc,eAAe,UAA2B;AACtD,QAAI;AACF,aAAU,cAAW,QAAQ;AAAA,IAC/B,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,gCAAgC,QAAQ,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,IACvH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAoB,WAAW,UAAoC;AACjE,QAAI;AACF,aAAO,MAAS,YAAS,OAAO,UAAa,aAAU,IAAI,EAAE,KAAK,MAAM,IAAI,EAAE,MAAM,MAAM,KAAK;AAAA,IACjG,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,gCAAgC,QAAQ,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,IACvH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAoB,cAAiB,QAAsD;AACzF,UAAM,EAAE,UAAU,KAAK,IAAI;AAC3B,QAAI;AACF,UAAI,CAAC,KAAI,eAAoB,aAAQ,QAAQ,CAAC,GAAG;AAC/C,aAAI,MAAW,aAAQ,QAAQ,CAAC;AAAA,MAClC;AACA,UAAI,YAAiB,CAAC;AACtB,UAAO,cAAW,QAAQ,GAAG;AAC3B,cAAM,WAAW,MAAS,YAAS,SAAS,UAAU,OAAO;AAC7D,oBAAY,KAAK,MAAM,QAAQ;AAC/B,YAAI,CAAC,MAAM,QAAQ,SAAS,EAAG,aAAY,CAAC;AAAA,MAC9C;AACA,gBAAU,KAAK,IAAI;AACnB,YAAM,cAAc,KAAK,UAAU,WAAW,MAAM,CAAC;AACrD,MAAG,iBAAc,UAAU,WAAW;AAAA,IACxC,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,2BAA2B,QAAQ,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,IAClH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAoB,uBAA0B,QAAwD;AACpG,UAAM,EAAE,UAAU,KAAK,IAAI;AAC3B,QAAI;AACF,UAAI,CAAI,cAAgB,aAAQ,QAAQ,CAAC,GAAG;AAC1C,aAAI,MAAW,aAAQ,QAAQ,CAAC;AAAA,MAClC;AACA,YAAM,cAAc,KAAK,UAAU,MAAM,MAAM,CAAC;AAChD,YAAS,YAAS,UAAU,UAAU,WAAW;AAAA,IACnD,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,+BAA+B,QAAQ,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,IACtH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAoB,aAAgB,UAAgC;AAClE,QAAI;AACF,UAAI,CAAI,cAAW,QAAQ,GAAG;AAC5B,cAAM,IAAI,MAAM,mBAAmB,QAAQ,EAAE;AAAA,MAC/C;AACA,YAAM,WAAW,MAAS,YAAS,SAAS,UAAU,OAAO;AAC7D,YAAM,MAAM,KAAK,MAAM,QAAQ;AAC/B,UAAI,CAAC,MAAM,QAAQ,GAAG,GAAG;AACvB,cAAM,IAAI,MAAM,iCAAiC,QAAQ,EAAE;AAAA,MAC7D;AACA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,4BAA4B,QAAQ,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,IACnH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAc,sBAAsB,QAAwB;AAC1D,QAAI,CAAC,OAAO,SAAS,MAAM,GAAG;AAC5B,YAAM,IAAI,MAAM,wBAAwB;AAAA,IAC1C;AACA,QAAI,OAAO,WAAW,GAAG;AACvB,YAAM,IAAI,MAAM,wBAAwB;AAAA,IAC1C;AACA,WAAc,kBAAW,QAAQ,EAAE,OAAO,MAAM,EAAE,OAAO,KAAK;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAc,sBAAsB,QAAwB;AAC1D,QAAI,CAAC,OAAO,SAAS,MAAM,GAAG;AAC5B,YAAM,IAAI,MAAM,wBAAwB;AAAA,IAC1C;AACA,QAAI,OAAO,WAAW,GAAG;AACvB,YAAM,IAAI,MAAM,wBAAwB;AAAA,IAC1C;AACA,WAAO,OAAO,WAAW,MAAM;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAa,iBAAiB,MAA2D;AACvF,UAAM,OAAO,KAAI,sBAAsB,OAAO,KAAK,KAAK,QAAQ,CAAC;AACjE,UAAM,OAAO,KAAI,sBAAsB,OAAO,KAAK,KAAK,QAAQ,CAAC;AACjE,UAAM,OAAO,SAAS,KAAK,QAAQ;AAEnC,QAAI;AACF,YAAM,WAAgB,aAAQ,QAAQ,IAAI,GAAG,KAAK,UAAU,KAAK,QAAQ;AACzE,YAAM,MAAW,aAAQ,QAAQ;AACjC,WAAI,MAAM,GAAG;AACb,YAAS,YAAS,UAAU,UAAU,KAAK,QAAQ;AAEnD,aAAO;AAAA,QACL,UAAU,KAAK;AAAA,QACf,SAAS;AAAA,QACT,UAAU;AAAA,QACV,UAAU;AAAA,QACV,UAAU;AAAA,QACV,YAAY,OAAO,KAAK,KAAK,QAAQ,EAAE,SAAS,QAAQ;AAAA,MAC1D;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,gCAAgC,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,IAC1G;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAoB,aAAa,MAA4D;AAC3F,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,KAAK,OAAO;AACzC,YAAM,SAAS,MAAM,SAAS,YAAY;AAC1C,YAAM,WAAgB,cAAS,KAAK,OAAO;AAC3C,YAAM,WAAgB,UAAK,KAAK,QAAQ,QAAQ;AAChD,MAAG,iBAAc,UAAU,OAAO,KAAK,MAAM,CAAC;AAC9C,aAAO;AAAA,QACL,UAAU;AAAA,QACV,SAAS;AAAA,QACT,UAAU,KAAI,sBAAsB,OAAO,KAAK,MAAM,CAAC;AAAA,QACvD,UAAU,KAAI,sBAAsB,OAAO,KAAK,MAAM,CAAC;AAAA,QACvD,UAAU,SAAS,QAAQ;AAAA,QAC3B,YAAY,OAAO,KAAK,MAAM,EAAE,SAAS,QAAQ;AAAA,MACnD;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,4BAA4B,KAAK,EAAE;AAAA,IACrD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAoB,aAAa,UAAmC;AAClE,QAAI;AACF,YAAM,OAAO,MAAS,YAAS,SAAS,UAAU,OAAO;AACzD,aAAO;AAAA,IACT,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,0BAA0B,QAAQ,EAAE;AAAA,IACtD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAa,qBAAqB,UAAkB;AAClD,QAAI;AACF,YAAM,OAAO,SAAS,QAAQ;AAC9B,YAAM,OAAO,MAAS,YAAS,SAAS,QAAQ;AAChD,aAAO;AAAA,QACL,YAAY;AAAA,UACV,MAAM,OAAO,KAAK,IAAI,EAAE,SAAS,QAAQ;AAAA,UACzC,UAAU;AAAA,QACZ;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,8CAA8C,KAAK,EAAE;AAAA,IACvE;AAAA,EACF;AACF;;;AEzTA,gBAAqB;AACrB,iBAAkB;AAEX,IAAM,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA,EAKvB,oBAAgB,gBAAK;AAAA,IACjB,aAAa;AAAA,IACb,YAAY,aAAE,OAAO,CAAC,CAAC;AAAA,IACvB,SAAS,YAAY,MAAM,MAAM,eAAe;AAAA,EACpD,CAAC;AACL;AAGO,IAAM,QAAN,MAAY;AAAA;AAAA;AAAA;AAAA;AAAA,EAMf,aAAoB,iBAAiB;AACjC,WAAO,KAAK,8BAA8B;AAAA,EAC9C;AACJ;;;AHiBO,IAAM,UAAN,MAAc;AAAA,EACX;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,eAAkC;AAAA,EAClC,UAAmB;AAAA,IACzB,gBAAgB,YAAY;AAAA,EAC9B;AAAA,EAEQ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMR,MAAc,eAAgC;AAC5C,QAAI,KAAK,sBAAsB,QAAW;AACxC,aAAO,KAAK;AAAA,IACd;AAEA,QAAI,KAAK,kBAAkB;AACzB,WAAK,oBAAoB,KAAK;AAC9B,aAAO,KAAK;AAAA,IACd;AAEA,QAAI,KAAK,kBAAkB;AACzB,UAAI;AACF,cAAM,SAAS,MAAM,IAAI,aAAa,KAAK,gBAAgB;AAC3D,YAAI,CAAC,QAAQ;AACX,gBAAM,IAAI,MAAM,wCAAwC;AAAA,QAC1D;AACA,aAAK,oBAAoB;AACzB,eAAO,KAAK;AAAA,MACd,SAAS,OAAO;AACd,cAAM,IAAI,MAAM,iCAAiC,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,MAC3G;AAAA,IACF;AAEA,SAAK,oBAAoB;AACzB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,YAAY,QAAuB;AACjC,QAAI;AACF,WAAK,eAAe,MAAM;AAC1B,WAAK,aAAa,OAAO;AACzB,WAAK,SAAS,OAAO;AACrB,WAAK,qBAAqB,MAAM;AAChC,WAAK,WAAW,OAAO,KAAK;AAG5B,WAAK,QAAQ,KAAK,UAAU;AAAA,QAC1B,OAAO,OAAO;AAAA,MAChB,CAAC;AAGD,WAAK,gBAAgB,OAAO;AAAA,IAC9B,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,0BAA0B,KAAK,EAAE;AAAA,IACnD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,eAAe,QAA6B;AAClD,UAAM,SAAmB,CAAC;AAE1B,QAAI,CAAC,OAAO,SAAU,QAAO,KAAK,uBAAuB;AACzD,QAAI,CAAC,OAAO,OAAQ,QAAO,KAAK,qBAAqB;AACrD,QAAI,CAAC,OAAO,MAAO,QAAO,KAAK,mBAAmB;AAElD,QAAI,OAAO,cAAc,QAAQ,OAAO,cAAc,MAAM;AAC1D,aAAO,KAAK,yDAAyD;AAAA,IACvE;AAEA,QAAI,OAAO,SAAS,GAAG;AACrB,YAAM,IAAI,MAAM,yBAAyB,OAAO,KAAK,IAAI,CAAC,EAAE;AAAA,IAC9D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,oBAAoB,EAAE,SAAS,OAAO,GAA8D;AAC1G,QAAI,UAAU,OAAO,WAAW,UAAU;AACxC,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACtD;AAEA,QAAI,WAAW,CAAC,MAAM,QAAQ,OAAO,GAAG;AACtC,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,qBAAqB,QAA6B;AACxD,SAAK,mBAAmB,OAAO,cAAc;AAC7C,SAAK,mBAAmB,OAAO,cAAc;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,WAAW,OAAuB;AACxC,QAAI,OAAO;AACT,WAAK,UAAU;AAAA,QACb,gBAAgB,YAAY;AAAA,QAC5B,GAAG;AAAA,MACL;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,UAAU;AAAA,IAChB;AAAA,EACF,GAEoB;AAClB,QAAI,OAAO,WAAW,SAAS,GAAG;AAChC,YAAM,kBAAc,wCAAyB;AAAA,QAC3C,QAAQ,KAAK;AAAA,QACb,SAAS,KAAK;AAAA,MAChB,CAAC;AACD,aAAO,YAAY,OAAO;AAAA,QACxB,oBAAoB;AAAA,MACtB,CAAC;AAAA,IACH,WAAW,OAAO,WAAW,MAAM,GAAG;AACpC,YAAMC,mBAAc,4BAAa;AAAA,QAC/B,SAAS,KAAK;AAAA,QACd,QAAQ,KAAK;AAAA,QACb,eAAe;AAAA,MACjB,CAAC;AACD,aAAOA,aAAY,KAAK;AAAA,IAC1B;AACA,UAAM,kBAAc,4BAAa;AAAA,MAC/B,SAAS,KAAK;AAAA,MACd,QAAQ,KAAK;AAAA,MACb,eAAe;AAAA,IACjB,CAAC;AACD,WAAO,YAAY,QAAQ;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAc,eAAuB;AAAA,IACnC;AAAA,IACA;AAAA,EACF,GAWG;AACD,WAAO,UAAM,2BAAe;AAAA,MAC1B,OAAO,KAAK;AAAA,MACZ,QAAQ,MAAM,KAAK,aAAa;AAAA,MAChC;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAc,aAAa;AAAA,IACzB;AAAA,EACF,GAMG;AACD,WAAO,UAAM,yBAAa;AAAA,MACxB,OAAO,KAAK;AAAA,MACZ,QAAQ,MAAM,KAAK,aAAa;AAAA,MAChC,OAAO,OAAO,KAAK,KAAK,OAAO,EAAE,SAAS,IAAI,KAAK,UAAU;AAAA,MAC7D,UAAU,OAAO,KAAK,KAAK,OAAO,EAAE,SAAS,IAAI,OAAO,mBAAmB;AAAA,MAC3E;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAc,eAAe;AAAA,IAC3B;AAAA,EACF,GAMG;AACD,eAAO,uBAAW;AAAA,MAChB,OAAO,KAAK;AAAA,MACZ,QAAQ,MAAM,KAAK,aAAa;AAAA,MAChC,OAAO,OAAO,KAAK,KAAK,OAAO,EAAE,SAAS,IAAI,KAAK,UAAU;AAAA,MAC7D,UAAU,OAAO,KAAK,KAAK,OAAO,EAAE,SAAS,IAAI,OAAO,mBAAmB;AAAA,MAC3E;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoCA,MAAa,MACX,QAgBuB;AACvB,UAAM,EAAE,SAAS,QAAQ,MAAM,IAAI;AACnC,QAAI;AACF,UAAI,CAAC,UAAU,OAAO,WAAW,UAAU;AACzC,cAAM,IAAI,MAAM,oCAAoC;AAAA,MACtD;AAEA,UAAI,WAAW,CAAC,MAAM,QAAQ,OAAO,GAAG;AACtC,cAAM,IAAI,MAAM,0CAA0C;AAAA,MAC5D;AAEA,YAAM,WAAW,KAAK,eAAe,EAAE,SAAS,QAAQ,MAAM,CAAC;AAE/D,aAAO;AAAA,QACL,cAAc,YAAY;AACxB,iBAAO,MAAM,KAAK,aAAa,EAAE,SAAS,CAAC;AAAA,QAC7C;AAAA,QACA,gBAAgB,YAAY;AAC1B,iBAAO,MAAM,KAAK,eAAe,EAAE,SAAS,CAAC;AAAA,QAC/C;AAAA,QACA,gBAAgB,OAAe,WAAiE;AAC9F,iBAAO,MAAM,KAAK,eAAe,EAAE,UAAU,OAAO,CAAC;AAAA,QACvD;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,YAAY,GAAG;AAClE,eAAO,KAAK,yCAAyC;AACrD,aAAK,QAAQ,KAAK,UAAU;AAAA,UAC1B,OAAO,KAAK;AAAA,QACd,CAAC;AACD,eAAO,MAAM,KAAK,MAAM,EAAE,SAAS,OAAO,CAAC;AAAA,MAC7C;AACA,YAAM,IAAI,MAAM,mBAAmB,KAAK,EAAE;AAAA,IAC5C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBA,MAAa,UACX,QAyB2B;AAC3B,UAAM,EAAE,eAAe,QAAQ,SAAS,QAAQ,MAAM,IAAI;AAC1D,QAAI;AACF,UAAI,CAAC,UAAU,OAAO,WAAW,UAAU;AACzC,cAAM,IAAI,MAAM,oCAAoC;AAAA,MACtD;AAEA,UAAI,WAAW,CAAC,MAAM,QAAQ,OAAO,GAAG;AACtC,cAAM,IAAI,MAAM,0CAA0C;AAAA,MAC5D;AAEA,WAAK,eAAe;AAEpB,YAAM,WAAW,KAAK,eAAe,EAAE,SAAS,QAAQ,MAAM,CAAC;AAE/D,aAAO,MAAM,KAAK,YAAY,QAAQ;AAAA,IACxC,SAAS,OAAO;AACd,UAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,YAAY,GAAG;AAClE,eAAO,KAAK,yCAAyC;AACrD,aAAK,QAAQ,KAAK,UAAU;AAAA,UAC1B,OAAO,KAAK;AAAA,QACd,CAAC;AACD,eAAO,MAAM,KAAK,UAAU,EAAE,SAAS,OAAO,CAAC;AAAA,MACjD;AACA,YAAM,IAAI,MAAM,mBAAmB,KAAK,EAAE;AAAA,IAC5C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYQ,eAAe;AAAA,IACrB;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAiBkB;AAChB,SAAK,oBAAoB,EAAE,SAAS,OAAO,CAAC;AAE5C,UAAM,eAAe,WAAW,QAAQ,SAAS,IAAI,CAAC,GAAG,OAAO,IAAI,CAAC;AAErE,UAAM,cAA2B,CAAC,SAAS,MAAM,eAAe,KAC5D;AAAA,MACA,MAAM;AAAA,MACN,SAAS;AAAA,IACX,IACE;AAAA,MACA,MAAM;AAAA,MACN,SAAS;AAAA,QACP;AAAA,UACE,MAAM;AAAA,UACN,MAAM;AAAA,QACR;AAAA,QACA;AAAA,UACE,MAAM;AAAA,UACN,MAAM,MAAM;AAAA,UACZ,UAAU,MAAM,YAAY;AAAA,QAC9B;AAAA,MACF;AAAA,IACF;AAEF,WAAO,CAAC,GAAG,cAAc,WAAW;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAc,YAKZ,UAC0B;AAC1B,QAAI,KAAK,iBAAiB,UAAU;AAClC,YAAM,aAAa,MAAM,KAAK,eAAe,EAAE,SAAS,CAAC;AACzD,aAAO,EAAE,YAAY,WAAW,YAAY,UAAU,WAAW,SAAS;AAAA,IAC5E;AAEA,UAAM,EAAE,MAAM,SAAS,IAAI,MAAM,KAAK,aAAa,EAAE,SAAS,CAAC;AAC/D,WAAO,EAAE,MAAM,SAAS;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAc,sBAAsB,EAAE,SAAS,GAAgC,aAAa,GAAiB;AAC3G,QAAI;AACF,aAAO,MAAM,KAAK,aAAa,EAAE,SAAS,CAAC;AAAA,IAC7C,SAAS,OAAO;AACd,UAAI,KAAK,wBAAwB,OAAO,UAAU,GAAG;AACnD,eAAO,KAAK,gCAAgC;AAC5C,aAAK,QAAQ,KAAK,UAAU,EAAE,OAAO,KAAK,cAAc,CAAC;AACzD,eAAO,MAAM,KAAK,sBAAsB,EAAE,SAAS,GAAG,aAAa,CAAC;AAAA,MACtE;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUQ,wBAAwB,OAAgB,YAA6B;AAC3E,UAAM,YAAY;AAClB,WAAO,aAAa,aAClB,CAAC,CAAC,KAAK,iBACP,iBAAiB,UAChB,MAAM,QAAQ,SAAS,YAAY,KAAK,MAAM,QAAQ,SAAS,OAAO;AAAA,EAC3E;AACF;;;AIpjBA,oBAAmC;AAG5B,SAAS,eAAe,MAAsB;AACnD,SAAO,cAAAC,QAAO,WAAW,QAAQ,EAAE,OAAO,IAAI,EAAE,OAAO,KAAK;AAC9D;AAEO,SAAS,eAAuB;AACrC,aAAO,0BAAW;AACpB;AAEO,SAAS,qBAAqB,QAAwB;AAC3D,SAAO,cAAAA,QAAO,YAAY,MAAM,EAAE,SAAS,KAAK,EAAE,MAAM,GAAG,MAAM;AACnE;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAoB;AACpB,oBAAmB;AACnB,cAAAC,QAAO,OAAO;AAEd,IAAM,WAAc,mBAAgB;AAAA,EAClC,OAAO,QAAQ;AAAA,EACf,QAAQ,QAAQ;AAAA,EAChB,UAAU;AAAA,EACV,WAAW,CAAC,SAAS;AACnB,UAAM,cAAc,CAAC,QAAQ,QAAQ,OAAO;AAC5C,UAAM,OAAO,YAAY,OAAO,CAAC,MAAM,EAAE,WAAW,IAAI,CAAC;AACzD,WAAO,CAAC,KAAK,SAAS,OAAO,aAAa,IAAI;AAAA,EAChD;AACF,CAAC;AAOD,eAAsB,SAAS,UAAoC;AACjE,SAAO,SAAS,SAAS,WAAW,WAAW,OAAO,IAAI;AAC5D;AAMA,eAAsB,gBAAgB;AACpC,QAAM,SAAS,MAAM;AACrB,UAAQ,KAAK,CAAC;AAChB;AAMA,eAAsB,gBAAgB;AACpC,UAAQ,OAAO,MAAM,OAAO;AAC5B,SAAO,SAAS,OAAO;AACzB;AAOA,eAAsB,MAAM,UAAiC;AAC3D,SAAO,IAAI,QAAQ,CAACC,aAAY,WAAWA,UAAS,WAAW,GAAI,CAAC;AACtE;AAYO,SAAS,aAAa,QAAsD;AACjF,QAAM,UAAU,OAAO,KAAK,QAAQ,GAAG,EAAE;AAAA,IAAO,CAAC,QAC/C,IAAI,WAAW,MAAM;AAAA,EACvB;AACA,QAAM,OAAiB,CAAC;AACxB,QAAM,SAAmB,CAAC;AAE1B,UAAQ,QAAQ,CAAC,QAAQ;AACvB,QAAI,QAAQ,IAAI,GAAG,GAAG;AACpB,WAAK,KAAK,GAAG;AACb,aAAO,KAAK,QAAQ,IAAI,GAAG,CAAE;AAAA,IAC/B;AAAA,EACF,CAAC;AAED,SAAO,EAAE,MAAM,OAAO;AACxB;;;ACtDO,IAAM,eAAN,MAAmB;AAAA,EACd;AAAA,EACA,aAAqB;AAAA,EACrB,oBAA4B;AAAA,EAC5B,WAA4B;AAAA,EAC5B,sBAAqC;AAAA,EACrC,kBAAiC;AAAA,EAEjC,gBAA+C,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMxD,YAAY,QAAuB;AAC/B,SAAK,WAAW,OAAO;AACvB,SAAK,aAAa,EAAE,MAAM,WAAS;AAC/B,YAAM,IAAI,MAAM,KAAK;AAAA,IACzB,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAc,eAAe;AACzB,QAAI;AACA,YAAM,WAAW,KAAK;AAEtB,UAAI,CAAC,UAAU;AACX,cAAM,IAAI,MAAM,iDAAiD;AAAA,MACrE;AACA,UAAI,CAAC,MAAM,IAAI,WAAW,KAAK,KAAK,UAAU,gBAAgB,GAAG;AAC7D,YAAI,uBAGD;AAAA,UACC,UAAU,KAAK,KAAK,UAAU;AAAA,UAC9B,MAAM,CAAC,EAAE,UAAU,WAAW,KAAK,eAAe,EAAE,CAAC;AAAA,QACzD,CAAC;AAAA,MACL;AAAA,IACJ,SAAS,OAAO;AACZ,YAAM,IAAI,MAAM,kCAAkC,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,IAE9G;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBA,MAAa,iBAAiB;AAAA,IAC1B;AAAA,EACJ,GAM2B;AACvB,UAAM,aAAa,KAAK,SAAS,KAAK,SAAS,KAAK,YAAY,KAAK,QAAQ;AAC7E,SAAK,WAAW;AAEhB,QAAI,CAAC,KAAK,cAAc,UAAU,GAAG;AACjC,WAAK,cAAc,UAAU,IAAI,CAAC;AAAA,IACtC;AAEA,WAAO;AAAA,MACH,MAAM,KAAK;AAAA,MACX,SAAS,KAAK,cAAc,UAAU;AAAA,MACtC,aAAa,OAAU,SAA4B;AAC/C,YAAI;AACJ,YAAI,UAAU,QAAQ,OAAO,KAAK,SAAS,UAAU;AACjD,oBAAU;AAAA,YACN,MAAM,KAAK;AAAA,YACX,SAAS;AAAA,cACL;AAAA,gBACI,MAAM;AAAA,gBACN,MAAM,KAAK;AAAA,cACf;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ,WAAW,aAAa,MAAM;AAC1B,oBAAU;AAAA,YACN,MAAM,KAAK;AAAA,YACX,SAAS;AAAA,cACL;AAAA,gBACI,MAAM;AAAA,gBACN,MAAM,OAAO,KAAK,YAAY,WACxB,KAAK,UACL,KAAK,UAAU,KAAK,SAAS,MAAM,CAAC;AAAA,cAC9C;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ,OAAO;AACH,gBAAM,IAAI,MAAM,sCAAsC;AAAA,QAC1D;AACA,aAAK,cAAc,UAAU,EAAE,KAAK,OAAO;AAC3C,eAAO,KAAK,cAAc,UAAU;AAAA,MACxC;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA+BA,MAAa,mBACT,QAeuB;AACvB,UAAM,EAAE,YAAY,MAAM,sBAAsB,IAAI;AAEpD,QAAI,CAAC,MAAM;AACP,YAAM,IAAI,MAAM,sCAAsC;AAAA,IAC1D;AACA,QAAI,CAAC,uBAAuB;AACxB,WAAK,kBAAkB,KAAK,KAAK,UAAU,IAAI,KAAK,iBAAiB,GAAG,KAAK,YAAY,KAAK,SAAS,KAAK,SAAS,KAAK,IAAI;AAAA,IAClI,WAAW,sBAAsB,SAAS,GAAG,GAAG;AAC5C,WAAK,kBAAkB;AAAA,IAC3B,OAAO;AACH,WAAK,kBAAkB,KAAK,KAAK,UAAU,IAAI,KAAK,iBAAiB,GAAG,qBAAqB;AAAA,IACjG;AACA,SAAK,aAAa,cAAc,KAAK;AACrC,SAAK,WAAW;AAChB,QAAI,MAAM,KAAK,KAAK,UAAU,EAAE;AAChC,UAAM,UAAU,MAAM,KAAK,sBAAsB;AAAA,MAC7C;AAAA,MACA,UAAU,KAAK;AAAA,IACnB,CAAC;AACD,QAAI,WAAW,QAAQ,QAAQ,SAAS,GAAG;AACvC,aAAO;AAAA,QACH,MAAM,QAAQ;AAAA,QACd,SAAS,QAAQ;AAAA,QACjB,aAAa,OAAU,SAA4B;AAC/C,iBAAO,KAAK,YAAe,IAAI;AAAA,QACnC;AAAA,MACJ;AAAA,IACJ;AACA,UAAM,oBAAoB,MAAM,KAAK,yBAAyB,EAAE,MAAM,UAAU,KAAK,gBAAgB,CAAC;AACtG,WAAO;AAAA,MACH,MAAM,kBAAkB;AAAA,MACxB,SAAS,kBAAkB;AAAA,MAC3B,aAAa,OAAU,SAA4B;AAC/C,eAAO,KAAK,YAAe,IAAI;AAAA,MACnC;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAc,YAAe,MAAyB;AAClD,QAAI,CAAC,KAAK,UAAU;AAChB,YAAM,IAAI,MAAM,yCAAyC;AAAA,IAC7D;AACA,UAAM,WAAW,KAAK,mBAAmB,KAAK,KAAK,UAAU,IAAI,KAAK,iBAAiB,GAAG,KAAK,UAAU,YAAY,KAAK,UAAU,SAAS,KAAK,UAAU,SAAS,KAAK,UAAU,IAAI;AACxL,UAAM,IAAI,cAAc;AAAA,MACpB;AAAA,MACA;AAAA,IACJ,CAAC;AACD,WAAO,MAAM,KAAK,WAAW,QAAQ;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAa,YAAY,MAA0C;AAC/D,UAAM,gBAAgB,KAAK,uBAAuB,KAAK,KAAK,UAAU;AACtE,QAAI,MAAM,IAAI,WAAW,aAAa,GAAG;AACrC,YAAM,UAAU,MAAM,IAAI,aAAuB,aAAa;AAC9D,YAAM,eAAe,QAAQ,KAAK,OAAK,EAAE,UAAU,KAAK,KAAK;AAC7D,UAAI,cAAc;AACd,eAAO;AAAA,MACX;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAa,WAAW,UAAkB;AACtC,UAAM,UAAU,MAAM,IAAI,aAAkC,QAAQ;AACpE,QAAI,CAAC,WAAW,QAAQ,WAAW,GAAG;AAClC,aAAO,CAAC;AAAA,IACZ;AACA,aAAS,KAAK,CAAC,GAAG,MAAM;AAEpB,YAAM,6BACF,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ,IAC9B,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ;AAClC,UAAI,+BAA+B,GAAG;AAClC,eAAO;AAAA,MACX;AAGA,YAAM,8BACF,IAAI,KAAK,EAAE,aAAa,CAAC,EAAE,QAAQ,IACnC,IAAI,KAAK,EAAE,aAAa,CAAC,EAAE,QAAQ;AACvC,aAAO;AAAA,IACX,CAAC;AAED,UAAM,UAAyB,CAAC;AAChC,YAAQ,QAAQ,CAAC,SAAS;AACtB,UAAI,UAAU,QAAQ,KAAK,SAAS,UAAU,OAAO,KAAK,SAAS,UAAU;AACzE,gBAAQ,KAAK;AAAA,UACT,MAAM,KAAK;AAAA,UACX,SAAS;AAAA,YACL;AAAA,cACI,MAAM;AAAA,cACN,MAAM,KAAK;AAAA,YACf;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL,WAAW,UAAU,QAAQ,KAAK,SAAS,eAAe,OAAO,KAAK,SAAS,UAAU;AACrF,gBAAQ,KAAK;AAAA,UACT,MAAM,KAAK;AAAA,UACX,SAAS;AAAA,YACL;AAAA,cACI,MAAM;AAAA,cACN,MAAM,KAAK;AAAA,YACf;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL,WAAW,aAAa,QAAQ,KAAK,SAAS,aAAa;AACvD,YAAI;AAEJ,YAAI,MAAM,QAAQ,KAAK,OAAO,GAAG;AAC7B,6BAAmB,KAAK,QAAQ,IAAI,CAAC,gBAAqB;AACtD,gBAAI,OAAO,gBAAgB,UAAU;AACjC,qBAAO;AAAA,gBACH,MAAM;AAAA,gBACN,MAAM;AAAA,cACV;AAAA,YACJ;AACA,mBAAO;AAAA,UACX,CAAC;AAAA,QACL,WAAW,OAAO,KAAK,YAAY,YAAY,KAAK,YAAY,MAAM;AAClE,6BAAmB,CAAC;AAAA,YAChB,MAAM;AAAA,YACN,MAAM,KAAK,UAAU,KAAK,SAAS,MAAM,CAAC;AAAA,UAC9C,CAAC;AAAA,QACL,OAAO;AACH,6BAAmB,CAAC;AAAA,YAChB,MAAM;AAAA,YACN,MAAM,OAAO,KAAK,OAAO;AAAA,UAC7B,CAAC;AAAA,QACL;AAEA,gBAAQ,KAAK;AAAA,UACT,MAAM,KAAK;AAAA,UACX,SAAS;AAAA,QACb,CAAC;AAAA,MACL;AAAA,IACJ,CAAC;AAED,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAc,0BAA0B,MAAgB;AACpD,QAAI,CAAC,MAAM;AACP,YAAM,IAAI,MAAM,uCAAuC;AAAA,IAC3D;AACA,UAAM,gBAAgB,KAAK,KAAK,UAAU;AAC1C,SAAK,sBAAsB;AAE3B,QAAI,MAAM,KAAK,KAAK,UAAU,EAAE;AAEhC,QAAI,QAAoB,CAAC;AACzB,QAAI,IAAI,eAAe,aAAa,GAAG;AACnC,cAAQ,MAAM,IAAI,aAAuB,aAAa;AACtD,YAAM,eAAe,MAAM,KAAK,OAAK,EAAE,aAAa,KAAK,YAAY,EAAE,UAAU,KAAK,SAAS,EAAE,UAAU,KAAK,SAAS,EAAE,SAAS,KAAK,IAAI;AAC7I,UAAI,cAAc;AACd,eAAO;AAAA,MACX;AACA,YAAM,KAAK,IAAI;AACf,YAAM,IAAI,uBAAuB;AAAA,QAC7B,UAAU;AAAA,QACV,MAAM;AAAA,MACV,CAAC;AACD,aAAO;AAAA,IACX,OAAO;AACH,YAAM,IAAI,uBAAuB;AAAA,QAC7B,UAAU;AAAA,QACV,MAAM,CAAC,IAAI;AAAA,MACf,CAAC;AACD,aAAO;AAAA,IACX;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAc,yBAAyB,EAAE,MAAM,SAAS,GAA2C;AAC/F,QAAI;AACA,UAAI,CAAC,MAAM;AACP,cAAM,IAAI,MAAM,uCAAuC;AAAA,MAC3D;AACA,YAAM,cAAc,MAAM,KAAK,0BAA0B,IAAI;AAC7D,YAAM,iBAAiB,KAAK,mBACxB,KAAK,KAAK,UAAU,IAAI,KAAK,iBAAiB,GAAG,KAAK,YAAY,KAAK,SAAS,KAAK,SAAS,KAAK,IAAI;AAE3G,YAAM,IAAI,uBAAuB,EAAE,UAAU,gBAAgB,MAAM,CAAC,EAAmB,CAAC;AACxF,aAAO;AAAA,QACH,MAAM;AAAA,QACN,SAAS,CAAC;AAAA,MACd;AAAA,IACJ,SAAS,OAAO;AACZ,YAAM,IAAI,MAAM,yCAAyC,KAAK,YAAY,KAAK,SAAS,KAAK,SAAS,KAAK,IAAI,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,IAChL;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAc,sBAAsB,EAAE,MAAM,SAAS,GAAgG;AACjJ,QAAI;AACA,YAAM,UAAU,MAAM,KAAK,WAAW,YAClC,KAAK,KAAK,UAAU,IAAI,KAAK,iBAAiB,GAAG,KAAK,YAAY,KAAK,SAAS,KAAK,SAAS,KAAK,IAAI,OAAO;AAClH,aAAO;AAAA,QACH;AAAA,QACA,SAAS;AAAA,MACb;AAAA,IACJ,SAAS,OAAO;AACZ,UAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,gBAAgB,GAAG;AACpE,eAAO;AAAA,UACH;AAAA,UACA,SAAS,CAAC;AAAA,QACd;AAAA,MACJ;AACA,YAAM,IAAI,MAAM,qCAAqC,KAAK,YAAY,KAAK,SAAS,KAAK,SAAS,KAAK,IAAI,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,IAC5K;AAAA,EACJ;AACJ;;;AVxaA,IAAAC,aAAqB;","names":["import_ai","chokidar","openAIModel","crypto","dotenv","resolve","import_ai"]}