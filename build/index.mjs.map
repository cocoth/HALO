{"version":3,"sources":["../src/utils/colors.ts","../src/utils/time.ts","../src/utils/logger.ts","../src/core/agent.ts","../src/lib/iof.ts","../src/utils/mimeType.ts","../src/core/tools.ts","../src/utils/hash.ts","../src/utils/terminal.ts","../src/lib/session.ts","../index.ts"],"sourcesContent":["\r\nexport const terminalColors = {\r\n    reset: '\\x1b[0m',\r\n    bright: '\\x1b[1m',\r\n    dim: '\\x1b[2m',\r\n    underscore: '\\x1b[4m',\r\n    blink: '\\x1b[5m',\r\n    reverse: '\\x1b[7m',\r\n    hidden: '\\x1b[8m',\r\n\r\n    BLK: '\\x1b[30m',\r\n    R: '\\x1b[31m',\r\n    G: '\\x1b[32m',\r\n    Y: '\\x1b[33m',\r\n    B: '\\x1b[34m',\r\n    M: '\\x1b[35m',\r\n    C: '\\x1b[36m',\r\n    W: '\\x1b[37m',\r\n\r\n    BBLK: '\\x1b[40m',\r\n    BR: '\\x1b[41m',\r\n    BG: '\\x1b[42m',\r\n    BY: '\\x1b[43m',\r\n    BB: '\\x1b[44m',\r\n    BM: '\\x1b[45m',\r\n    BC: '\\x1b[46m',\r\n    BW: '\\x1b[47m'\r\n};","\r\nexport class Time {\r\n  private static formatDateToParts(\r\n    date: Date,\r\n    timeZone: string\r\n  ): { [key: string]: string } {\r\n    const formatter = new Intl.DateTimeFormat(\"id-ID\", {\r\n      timeZone,\r\n      year: \"numeric\",\r\n      month: \"2-digit\",\r\n      day: \"2-digit\",\r\n      hour: \"2-digit\",\r\n      minute: \"2-digit\",\r\n      second: \"2-digit\",\r\n      hour12: false,\r\n    });\r\n\r\n    const formattedParts = formatter.formatToParts(date);\r\n    const dateParts: { [key: string]: string } = {};\r\n\r\n    formattedParts.forEach(({ type, value }) => {\r\n      dateParts[type] = value;\r\n    });\r\n\r\n    return dateParts;\r\n  }\r\n\r\n  private static formatDateString(dateParts: { [key: string]: string }): string {\r\n    return `${dateParts.year}-${dateParts.month}-${dateParts.day}T${dateParts.hour}:${dateParts.minute}:${dateParts.second}Z`;\r\n  }\r\n\r\n  private static formateDateToSaveString(dateParts: { [key: string]: string }): string {\r\n    return `${dateParts.year}-${dateParts.month}-${dateParts.day}T${dateParts.hour}-${dateParts.minute}-${dateParts.second}Z`;\r\n  }\r\n\r\n  private static logFormat(dateParts: { [key: string]: string }): string {\r\n    return `${dateParts.day}/${dateParts.month}/${dateParts.year}:${dateParts.hour}:${dateParts.minute}:${dateParts.second}`;\r\n  }\r\n\r\n  public static formatDateToHumanReadable(\r\n    date: Date,\r\n    timeZone: string\r\n  ): string {\r\n    const dateParts = Time.formatDateToParts(date, timeZone);\r\n    return `${dateParts.day}/${dateParts.month}/${dateParts.year} ${dateParts.hour}:${dateParts.minute}:${dateParts.second}`;\r\n  }\r\n\r\n  /**\r\n   * Returns the current time formatted as a string suitable for saving.\r\n   * This format is `YYYY-MM-DDTHH-MM-SSZ`, which is useful for file naming or database storage.\r\n   */\r\n  public static getCurrentTimeToSaveString(): string {\r\n    const now = new Date();\r\n    const dateParts = Time.formatDateToParts(now, \"Asia/Jakarta\");\r\n    return Time.formateDateToSaveString(dateParts);\r\n  }\r\n\r\n  /**\r\n   * Returns the current time as a Date object.\r\n   * This method formats the current time to a string and then converts it back to a Date object.\r\n   */\r\n  public static getCurrentTime(): Date {\r\n    const now = new Date();\r\n    const dateParts = Time.formatDateToParts(now, \"Asia/Jakarta\");\r\n    const formattedDateString = Time.formatDateString(dateParts);\r\n    return new Date(formattedDateString);\r\n  }\r\n\r\n  /**\r\n   * Returns the current time formatted as a string.\r\n   * This format is `YYYY-MM-DDTHH:MM:SSZ`, which is useful for logging or displaying the current time.\r\n   */\r\n  public static getCurrentTimeToString(): string {\r\n    const now = new Date();\r\n    const dateParts = Time.formatDateToParts(now, \"Asia/Jakarta\");\r\n    return Time.formatDateString(dateParts);\r\n  }\r\n\r\n  /**\r\n   * Returns the current time in a human-readable format.\r\n   * This format is `DD/MM/YYYY HH:MM:SS`, which is suitable for display to users.\r\n   */\r\n  public static getCurrentTimeToHumanReadable(): string {\r\n    const now = new Date();\r\n    return Time.formatDateToHumanReadable(now, \"Asia/Jakarta\");\r\n  }\r\n\r\n  /**\r\n   * Returns the current time formatted for logging.\r\n   * This format is `DD/MM/YYYY:HH:MM:SS`, which is useful for log entries.\r\n   */\r\n  public static getTimeToLogFormat(): string {\r\n    const now = new Date();\r\n    const dateParts = Time.formatDateToParts(now, \"Asia/Jakarta\");\r\n    return Time.logFormat(dateParts);\r\n  }\r\n\r\n}\r\n","import { terminalColors as TC } from \"@/utils/colors\";\r\nimport { Time } from \"@/utils/time\";\r\n\r\n\r\n\r\nexport class Logger {\r\n    private static log(type: \"DEBUG\" | \"WARN\" | \"ERROR\" | \"INFO\" | \"SUCCESS\", message: string, funcName?: string) {\r\n      const colorMap = {\r\n        DEBUG: TC.M,\r\n        WARN: TC.BY,\r\n        ERROR: TC.R,\r\n        INFO: TC.B,\r\n        SUCCESS: TC.G,\r\n      };\r\n      const color = colorMap[type] || TC.reset;\r\n      const currentTime = Time.getTimeToLogFormat();\r\n      const functionName = funcName ? `funcName: ${funcName}` : \"\";\r\n      const logMethod = type === \"ERROR\" || type === \"WARN\" ? console.log : type === \"INFO\" ? console.info : console.log;\r\n      logMethod(`${TC.dim}[${currentTime}]${TC.reset} ${color}[${type}]${TC.reset} ${functionName}: ${message}`);\r\n    }\r\n  \r\n    static success(message: string, funcName?: string) {\r\n      this.log(\"SUCCESS\", message, funcName);\r\n    }\r\n  \r\n    static error(message: string, funcName?: string) {\r\n      this.log(\"ERROR\", message, funcName);\r\n    }\r\n  \r\n    static warn(message: string, funcName?: string) {\r\n      this.log(\"WARN\", message, funcName);\r\n    }\r\n  \r\n    static info(message: string, funcName?: string) {\r\n      this.log(\"INFO\", message, funcName);\r\n    }\r\n  \r\n    static debug(message: string, funcName?: string) {\r\n      this.log(\"DEBUG\", message, funcName);\r\n    }\r\n    static custom(type: string, message: string, funcName?: string) {\r\n      const functionName = funcName ? `funcName: ${funcName}` : \"\"\r\n      const currentTime = Time.getTimeToLogFormat()\r\n      console.log(`${TC.dim}[${currentTime}]${TC.reset} ${TC.C}[${type}]${TC.reset} ${functionName}: ${message}`);\r\n    }\r\n  }\r\n  ","import { Logger } from \"@/utils/logger\";\r\nimport { createOpenAI, openai } from \"@ai-sdk/openai\";\r\nimport {\r\n  CoreMessage,\r\n  generateObject,\r\n  generateText,\r\n  LanguageModelV1,\r\n  streamText,\r\n  ToolSet,\r\n} from \"ai\";\r\nimport { IOF } from \"@/lib/iof\";\r\nimport { createGoogleGenerativeAI, google } from \"@ai-sdk/google\";\r\nimport { TaskHandler } from \"@/core/tools\";\r\nimport type { InlineData, LooseToStrict, StartChatResult, UserBase } from \"@/types\";\r\n\r\ntype ModelID = Parameters<typeof google | typeof openai>[0]\r\n\r\n\r\ninterface AiAgentConfig {\r\n  /**\r\n   * The URL of the AI agent service.\r\n   * This is required to connect to the AI service.\r\n   */\r\n  agentUrl: string;\r\n  /**\r\n   * The API key for the AI agent.\r\n   * This is required to authenticate requests to the AI service.\r\n   */\r\n  apiKey: string;\r\n  /**\r\n   * The model ID to use for the AI agent.\r\n   * It can be a Google Gemini model (e.g., \"gemini-1.5-flash\") or an OpenAI model (e.g., \"gpt-4o\").\r\n   * If not provided, defaults to \"gpt-4o\".\r\n   */\r\n  model: LooseToStrict<ModelID>\r\n  /**\r\n   * fallbackModel is an model ID that can be used as a fallback\r\n   * if the primary model fails or is not available.\r\n   */\r\n  fallbackModel: LooseToStrict<ModelID>;\r\n  /**\r\n   * The method to use for streaming responses.\r\n   * Can be \"stream\" for streaming responses or \"text\" for text responses.\r\n   * Default is \"text\".\r\n   */\r\n  streamMethod?: \"text\" | \"stream\";\r\n  /**\r\n  * The file path to the system prompt.\r\n  * If not provided, the system prompt will be empty.\r\n  */\r\n  systemPromptFile?: string;\r\n  /**\r\n   * A set of tools that the AI agent can use to perform specific tasks.\r\n   * These tools can be used to interact with external services or perform actions.\r\n   * The tools are defined using the `tool` function from the `ai` library.\r\n   */\r\n  tools?: ToolSet\r\n}\r\n\r\n/**\r\n * AiAgent class for interacting with an AI agent via OpenAI API.\r\n * It initializes the agent with a URL and API key, and allows starting a chat session.\r\n * The system prompt can be loaded from a specified file.\r\n */\r\nexport class AiAgent {\r\n  private aiAgentUrl: string;\r\n  private apiKey: string;\r\n  private model: LanguageModelV1;\r\n  private fallbackModel?: LooseToStrict<ModelID>;\r\n  private systemPromptFile?: string;\r\n  private streamMethod: \"text\" | \"stream\" = \"text\";\r\n  private toolSet: ToolSet = {\r\n    getCurrentTime: TaskHandler.getCurrentTime\r\n  };\r\n\r\n  constructor(config: AiAgentConfig) {\r\n    try {\r\n      this.aiAgentUrl = config.agentUrl;\r\n      this.apiKey = config.apiKey;\r\n      this.streamMethod = config.streamMethod || \"text\";\r\n      this.systemPromptFile = config.systemPromptFile;\r\n\r\n      if (!this.aiAgentUrl || !this.apiKey) {\r\n        throw new Error(\"Agent URL and API key are required.\");\r\n      }\r\n      this.model = this.init({\r\n        model: config.model as LooseToStrict<ModelID>\r\n      });\r\n\r\n      if (config.fallbackModel) {\r\n        this.fallbackModel = config.fallbackModel;\r\n      }\r\n\r\n      if (config.tools) {\r\n        this.toolSet = {\r\n          getCurrentTime: TaskHandler.getCurrentTime,\r\n          ...config.tools\r\n        };\r\n      }\r\n    } catch (error) {\r\n      throw new Error(`Invalid configuration: ${error}`);\r\n    }\r\n  }\r\n\r\n  private init({\r\n    model,\r\n  }: {\r\n    model?: LooseToStrict<ModelID>\r\n  }): LanguageModelV1 {\r\n    if (model?.startsWith(\"gemini-\")) {\r\n      const googleModel = createGoogleGenerativeAI({\r\n        apiKey: this.apiKey,\r\n        baseURL: this.aiAgentUrl,\r\n      });\r\n      return googleModel(model, {\r\n        useSearchGrounding: true\r\n      });\r\n    } else if (model?.startsWith(\"gpt-\")) {\r\n      const openAIModel = createOpenAI({\r\n        baseURL: this.aiAgentUrl,\r\n        apiKey: this.apiKey,\r\n        compatibility: \"strict\",\r\n      });\r\n      return openAIModel(model);\r\n    }\r\n    const openAIModel = createOpenAI({\r\n      baseURL: this.aiAgentUrl,\r\n      apiKey: this.apiKey,\r\n      compatibility: \"strict\",\r\n    });\r\n    return openAIModel(\"gpt-4o\");\r\n  }\r\n\r\n  /**\r\n   * Loads the system prompt from a specified file.\r\n   * If the file is not found or empty, it throws an error.\r\n   */\r\n  private async systemPrompt(): Promise<string> {\r\n    if (!this.systemPromptFile) {\r\n      return \"\";\r\n    }\r\n    const system = await IOF.readTextFile(this.systemPromptFile);\r\n    if (!system) {\r\n      throw new Error(\"System prompt file not found or empty.\");\r\n    }\r\n    return system;\r\n  }\r\n\r\n  /**\r\n   * Retrieves user information based on the provided user base.\r\n   * This method can be extended to fetch user details from a database or an API.\r\n   */\r\n  private async getUserInfo(userData: UserBase): Promise<string> {\r\n    const greetingName = `Hai My Username Is: ${userData.username || userData.name || \"\"}, `;\r\n    const greetingPhone = `My Phone Number Is: ${userData.phone || \"\"}. \\n`;\r\n\r\n    return greetingName + greetingPhone;\r\n  }\r\n\r\n\r\n  /**\r\n   * Generates a stream of text responses based on the provided messages.\r\n   * It uses the AI agent's model and system prompt to generate the responses.\r\n   * If tools are defined, it will use them in the generation process.\r\n   *\r\n   * @param messages - An optional array of CoreMessage objects representing the conversation history.\r\n   * @param prompt - An optional prompt string to start the conversation.\r\n   * @returns A stream of text responses generated by the AI agent.\r\n   */\r\n  private async generateText({ messages, prompt }: { messages?: CoreMessage[]; prompt?: string; }) {\r\n    if (prompt && typeof prompt !== \"string\") {\r\n      throw new Error(\"Prompt must be a string.\");\r\n    }\r\n    if (messages && !Array.isArray(messages)) {\r\n      throw new Error(\"Messages must be an array of CoreMessage.\");\r\n    }\r\n\r\n    if (prompt) {\r\n      return await generateText({\r\n        model: this.model,\r\n        system: await this.systemPrompt(),\r\n        tools: Object.keys(this.toolSet).length > 0 ? this.toolSet : undefined,\r\n        maxSteps: Object.keys(this.toolSet).length > 0 ? Number.MAX_SAFE_INTEGER : undefined,\r\n        prompt,\r\n        // toolChoice: Object.keys(this.toolSet).length > 0 ? \"required\" : \"auto\"\r\n      });\r\n    }\r\n    return await generateText({\r\n      model: this.model,\r\n      system: await this.systemPrompt(),\r\n      tools: Object.keys(this.toolSet).length > 0 ? this.toolSet : undefined,\r\n      maxSteps: Object.keys(this.toolSet).length > 0 ? Number.MAX_SAFE_INTEGER : undefined,\r\n      // toolChoice: Object.keys(this.toolSet).length > 0 ? \"required\" : \"required\",\r\n      messages,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generates a text stream based on the provided messages.\r\n   * This method is used for streaming responses from the AI agent.\r\n   * It uses the `streamText` function from the `ai` library.\r\n   *\r\n   * @param messages - An array of CoreMessage objects representing the conversation history.\r\n   * @returns A stream of text responses from the AI agent.\r\n   */\r\n  private async generateStream(messages: CoreMessage[]) {\r\n    return streamText({\r\n      model: this.model,\r\n      system: await this.systemPrompt(),\r\n      tools: Object.keys(this.toolSet).length > 0 ? this.toolSet : undefined,\r\n      maxSteps: Object.keys(this.toolSet).length > 0 ? Number.MAX_SAFE_INTEGER : undefined,\r\n      messages,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Starts a chat session with the AI agent.\r\n   * It saves the user's message and response to the database.\r\n   * If a session is provided, it continues the conversation with the existing messages.\r\n   * If the prompt is invalid or empty, it throws an error.\r\n   *\r\n   * @param user - The user initiating the chat session.\r\n   * @param session - An optional array of previous messages in the chat session.\r\n   * @param prompt - The user's message to start the chat.\r\n   * @param media - Optional media data to include in the chat.\r\n   * @returns An object containing the text stream, text response, and response object.\r\n   */\r\n  public async startChat({\r\n    user,\r\n    session,\r\n    prompt,\r\n    media,\r\n  }: {\r\n    /**\r\n     * The user initiating the chat session.\r\n     * This can be a user base object containing user details like name and phone number.\r\n     * If not provided, the chat will not include user-specific information.\r\n     */\r\n    user?: UserBase | null;\r\n    /**\r\n     * An optional array of previous messages in the chat session.\r\n     * This allows the AI agent to continue the conversation with the existing context.\r\n     * If not provided, a new chat session will be started.\r\n     */\r\n    session?: CoreMessage[] | null;\r\n    /**\r\n     * The user's message to start the chat.\r\n     * This should be a non-empty string representing the user's input.\r\n     * If the prompt is invalid or empty, an error will be thrown.\r\n     */\r\n    prompt: string;\r\n    /**\r\n     * Optional media data to include in the chat.\r\n     * This can be an inline data object containing file data and mime type.\r\n     * If not provided, the chat will not include any media.\r\n     */\r\n    media?: InlineData | null;\r\n  }): Promise<StartChatResult> {\r\n    try {\r\n      if (!prompt || typeof prompt !== \"string\") {\r\n        throw new Error(\"Prompt must be a non-empty string.\");\r\n      }\r\n\r\n      if (session && !Array.isArray(session)) {\r\n        throw new Error(\"Session must be an array of CoreMessage.\");\r\n      }\r\n\r\n      if (session && session.length > 0) {\r\n        let messages: CoreMessage[] = [];\r\n\r\n        if (!media || media.inlineData === \"\") {\r\n          messages = [\r\n            ...session,\r\n            {\r\n              role: \"user\",\r\n              content: prompt,\r\n            },\r\n          ];\r\n        } else {\r\n          messages = [\r\n            ...session,\r\n            {\r\n              role: \"user\",\r\n              content: [\r\n                {\r\n                  type: \"text\",\r\n                  text: prompt,\r\n                },\r\n                {\r\n                  type: \"file\",\r\n                  data: media.inlineData,\r\n                  mimeType: media.mimeType || \"application/octet-stream\",\r\n                },\r\n              ],\r\n            },\r\n          ];\r\n        }\r\n\r\n        if (this.streamMethod === \"stream\") {\r\n          const textStream = await this.generateStream(messages);\r\n          return { textStream: textStream.textStream, response: textStream.response };\r\n        }\r\n\r\n        const { text, response } = await this.generateText({ messages });\r\n        return { text, response };\r\n      }\r\n\r\n      const greeting = user ? await this.getUserInfo(user) : \"\";\r\n      const fullPrompt = `${greeting} ${prompt}`;\r\n\r\n      if (this.streamMethod === \"stream\") {\r\n        const textStream = await this.generateStream([\r\n          {\r\n            role: \"user\",\r\n            content: fullPrompt,\r\n          },\r\n        ]);\r\n        return { textStream: textStream.textStream, response: textStream.response };\r\n      }\r\n\r\n      const { text, response } = await this.generateText({ prompt: fullPrompt });\r\n      return { text, response };\r\n\r\n    } catch (error) {\r\n      if (error instanceof Error && error.message.includes(\"Rate limit\")) {\r\n        Logger.warn(\"Rate limit exceeded, switching model...\");\r\n        this.model = this.init({\r\n          model: this.fallbackModel\r\n        });\r\n        return await this.startChat({ user, session, prompt });\r\n      }\r\n      throw new Error(`AI Agent test chat failed: ${error}`);\r\n    }\r\n  }\r\n}\r\n","import * as crypto from \"crypto\";\r\nimport * as path from \"path\";\r\nimport * as fs from \"fs\";\r\n\r\nimport { Logger } from \"@/utils/logger\";\r\nimport { mimeType } from \"@/utils/mimeType\";\r\nimport { FileDownloadInterface, FileInterface, FileStorageInterface } from \"@/types\";\r\n\r\n/** IOF (Input/Output File) class for handling file operations\r\n * - Calculates a SHA-256 hash of a given buffer.\r\n * - Provides a method to get the file path based on the hash.\r\n * - Allows setting a file location by saving the file and storing its metadata.\r\n * - Downloads a file from a URL and saves it to a specified path.\r\n * - Calculates the size of a file based on its buffer.\r\n * - Retrieves file paths based on hashes or buffers.\r\n * - Handles file storage operations using a repository pattern.\r\n * - Uses the FileStorageRepo for database interactions related to file storage.\r\n * - Uses the UserRepo for user-related database interactions.\r\n **/\r\nexport class IOF {\r\n\r\n  /**\r\n   * Creates a directory if it does not exist.\r\n   * @param dirPath - The path of the directory to create.\r\n   */\r\n  public static mkdir(dirPath: string): void {\r\n    try {\r\n      if (!fs.existsSync(dirPath)) {\r\n        Logger.info(`Creating directory: ${dirPath}`);\r\n        fs.mkdirSync(dirPath, { recursive: true });\r\n      }\r\n    } catch (error) {\r\n      throw new Error(`Failed to create directory at ${dirPath}:  ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if a file exists at the specified path.\r\n   * @param filePath - The path to the file.\r\n   * @returns A boolean indicating whether the file exists.\r\n   * @throws An error if the existence check fails.\r\n   */\r\n  public static existsFileSync(filePath: string): boolean {\r\n    try {\r\n      return fs.existsSync(filePath);\r\n    } catch (error) {\r\n      throw new Error(`Failed to check existence of ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Asynchronously checks if a file exists at the specified path.\r\n   * @param filePath - The path to the file.\r\n   * @returns A promise that resolves to a boolean indicating whether the file exists.\r\n   * @throws An error if the existence check fails.\r\n   */\r\n  public static async existsFile(filePath: string): Promise<boolean> {\r\n    try {\r\n      return await fs.promises.access(filePath, fs.constants.F_OK).then(() => true).catch(() => false);\r\n    } catch (error) {\r\n      throw new Error(`Failed to check existence of ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Writes an object to a JSON file, appending it to an existing array if the file already exists.\r\n   * @param filePath - The path to the JSON file.\r\n   * @param data - The object to write to the file.\r\n   * @throws An error if the file cannot be written or if the content is not an array.\r\n   */\r\n  public static async writeJSONFile<T>({ filePath, data }: { filePath: string; data: T }): Promise<void> {\r\n    try {\r\n      if (!IOF.existsFileSync(path.dirname(filePath))) {\r\n        IOF.mkdir(path.dirname(filePath));\r\n      }\r\n      let arrayData: T[] = [];\r\n      if (fs.existsSync(filePath)) {\r\n        const jsonData = await fs.promises.readFile(filePath, \"utf-8\");\r\n        arrayData = JSON.parse(jsonData);\r\n        if (!Array.isArray(arrayData)) arrayData = [];\r\n      }\r\n      arrayData.push(data);\r\n      const newJsonData = JSON.stringify(arrayData, null, 2);\r\n      fs.writeFileSync(filePath, newJsonData);\r\n    } catch (error) {\r\n      throw new Error(`Failed to write JSON to ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Overwrites a JSON file with a new array of objects.\r\n   * @param filePath - The path to the JSON file.\r\n   * @param data - The array of objects to write to the file.\r\n   * @throws An error if the file cannot be written or if the content is not an array.\r\n   */\r\n  public static async writeJSONFileOverwrite<T>({ filePath, data }: { filePath: string; data: T[] }): Promise<void> {\r\n    try {\r\n      if (!fs.existsSync(path.dirname(filePath))) {\r\n        IOF.mkdir(path.dirname(filePath));\r\n      }\r\n      const newJsonData = JSON.stringify(data, null, 2);\r\n      await fs.promises.writeFile(filePath, newJsonData);\r\n    } catch (error) {\r\n      throw new Error(`Failed to overwrite JSON to ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reads a JSON file and returns its content as an array.\r\n   * @param filePath - The path to the JSON file.\r\n   * @returns An array of objects parsed from the JSON file.\r\n   * @throws An error if the file does not exist or if the content is not an array.\r\n   */\r\n  public static async readJSONFile<T>(filePath: string): Promise<T[]> {\r\n    try {\r\n      if (!fs.existsSync(filePath)) {\r\n        throw new Error(`File not found: ${filePath}`);\r\n      }\r\n      const jsonData = await fs.promises.readFile(filePath, \"utf-8\");\r\n      const arr = JSON.parse(jsonData);\r\n      if (!Array.isArray(arr)) {\r\n        throw new Error(`File content is not an array: ${filePath}`);\r\n      }\r\n      return arr as T[];\r\n    } catch (error) {\r\n      throw new Error(`Failed to read JSON from ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates the SHA-256 hash of a given buffer.\r\n   * @param buffer - The buffer to hash.\r\n   * @returns The SHA-256 hash as a hexadecimal string.\r\n   */\r\n  public static calculateHashByBuffer(buffer: Buffer): string {\r\n    if (!Buffer.isBuffer(buffer)) {\r\n      throw new Error(\"Input must be a Buffer\");\r\n    }\r\n    if (buffer.length === 0) {\r\n      throw new Error(\"Buffer cannot be empty\");\r\n    }\r\n    return crypto.createHash(\"sha256\").update(buffer).digest(\"hex\");\r\n  }\r\n\r\n  /**\r\n   * Calculates the size of a file based on its buffer.\r\n   * @param buffer - The buffer representing the file.\r\n   * @returns The size of the file in bytes.\r\n   */\r\n  public static calculateSizeByBuffer(buffer: Buffer): number {\r\n    if (!Buffer.isBuffer(buffer)) {\r\n      throw new Error(\"Input must be a Buffer\");\r\n    }\r\n    if (buffer.length === 0) {\r\n      throw new Error(\"Buffer cannot be empty\");\r\n    }\r\n    return Buffer.byteLength(buffer);\r\n  }\r\n\r\n\r\n  /**\r\n   * Saves a file buffer to the specified file path on disk.\r\n   *\r\n   * Calculates the file's hash, size, and MIME type, creates the necessary directories,\r\n   * and writes the file data to disk. Returns an object containing metadata about the saved file.\r\n   *\r\n   * @param data - An object implementing the FileInterface, containing the file data, filename, and target filepath.\r\n   * @returns A promise that resolves to a FileStorageInterface object with file metadata, or null if saving fails.\r\n   * @throws {Error} If the file cannot be saved to the specified location.\r\n   */\r\n  public async saveBufferToFile(data: FileInterface): Promise<FileStorageInterface | null> {\r\n    const hash = IOF.calculateHashByBuffer(Buffer.from(data.filedata));\r\n    const size = IOF.calculateSizeByBuffer(Buffer.from(data.filedata));\r\n    const type = mimeType(data.filename);\r\n\r\n    try {\r\n      const fullPath = path.resolve(process.cwd(), data.filepath, data.filename);\r\n      const dir = path.dirname(fullPath);\r\n      IOF.mkdir(dir);\r\n      await fs.promises.writeFile(fullPath, data.filedata);\r\n\r\n      return {\r\n        filename: data.filename,\r\n        fileuri: fullPath,\r\n        filehash: hash,\r\n        filesize: size,\r\n        filetype: type,\r\n      };\r\n    } catch (error) {\r\n      throw new Error(`Failed to set file location: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Downloads a file from a given URL and saves it to the specified download path.\r\n   * @param data - The file download data including the file URL and save path.\r\n   * @returns The metadata of the downloaded file.\r\n   */\r\n  public static async downloadFile(data: FileDownloadInterface): Promise<FileStorageInterface> {\r\n    try {\r\n      const response = await fetch(data.fileuri);\r\n      const buffer = await response.arrayBuffer();\r\n      const fileName = path.basename(data.fileuri);\r\n      const filePath = path.join(data.saveTo, fileName);\r\n      fs.writeFileSync(filePath, Buffer.from(buffer));\r\n      return {\r\n        filename: fileName,\r\n        fileuri: filePath,\r\n        filehash: IOF.calculateHashByBuffer(Buffer.from(buffer)),\r\n        filesize: IOF.calculateSizeByBuffer(Buffer.from(buffer)),\r\n        filetype: mimeType(fileName),\r\n      };\r\n    } catch (error) {\r\n      throw new Error(`Failed to download file: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves the string content of a text file.\r\n   * @param filePath - The path to the text file.\r\n   * @returns A promise that resolves to the content of the file as a string.\r\n   * @throws An error if the file cannot be read.\r\n   */\r\n  public static async readTextFile(filePath: string): Promise<string> {\r\n    try {\r\n      const data = await fs.promises.readFile(filePath, \"utf-8\");\r\n      return data;\r\n    } catch (error) {\r\n      throw new Error(`Failed to read file at ${filePath}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts a file to a generative path format.\r\n   * @param fileName - The name of the file to convert.\r\n   * @returns An object containing the inline data with base64 encoded content and MIME type.\r\n   * @throws An error if the file cannot be read or converted.\r\n   */\r\n  public async fileToGenerativePath(fileName: string) {\r\n    try {\r\n      const mime = mimeType(fileName);\r\n      const file = await fs.promises.readFile(fileName);\r\n      return {\r\n        inlineData: {\r\n          data: Buffer.from(file).toString(\"base64\"),\r\n          mimeType: mime,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      throw new Error(`Failed to convert file to generative path: ${error}`);\r\n    }\r\n  }\r\n}\r\n","export function mimeType(fileName: string) {\r\n    const ext = fileName.split(\".\").pop();\r\n    switch (ext) {\r\n      // video\r\n      case \"mp4\":\r\n      case \"m4a\":\r\n      case \"m4b\":\r\n      case \"m4p\":\r\n      case \"m4r\":\r\n      case \"mpeg\":\r\n      case \"mpg\":\r\n      case \"mpe\":\r\n      case \"mpv\":\r\n      case \"mp2\":\r\n      case \"m2v\":\r\n      case \"m2ts\":\r\n      case \"mts\":\r\n      case \"tts\":\r\n      case \"m2t\":\r\n      case \"tsv\":\r\n      case \"tsa\":\r\n        return \"video/mpeg\";\r\n      case \"webm\":\r\n        return \"video/webm\";\r\n      case \"3gp\":\r\n        return \"video/3gpp\";\r\n      case \"mkv\":\r\n        return \"video/x-matroska\";\r\n      case \"avi\":\r\n        return \"video/x-msvideo\";\r\n      case \"mov\":\r\n        return \"video/quicktime\";\r\n      case \"wmv\":\r\n        return \"video/x-ms-wmv\";\r\n      case \"flv\":\r\n        return \"video/x-flv\";\r\n      case \"m4v\":\r\n        return \"video/x-m4v\";\r\n  \r\n      //  audio\r\n      case \"mp3\":\r\n        return \"audio/mpeg\";\r\n      case \"wav\":\r\n        return \"audio/wav\";\r\n      case \"ogg\":\r\n        return \"audio/ogg\";\r\n      case \"aac\":\r\n        return \"audio/aac\";\r\n      case \"flac\":\r\n        return \"audio/flac\";\r\n      case \"alac\":\r\n        return \"audio/alac\";\r\n  \r\n      // image\r\n      case \"jpg\":\r\n      case \"jpeg\":\r\n        return \"image/jpeg\";\r\n      case \"png\":\r\n        return \"image/png\";\r\n      case \"gif\":\r\n        return \"image/gif\";\r\n      case \"bmp\":\r\n        return \"image/bmp\";\r\n      case \"webp\":\r\n        return \"image/webp\";\r\n      case \"svg\":\r\n        return \"image/svg+xml\";\r\n      case \"ico\":\r\n        return \"image/x-icon\";\r\n      case \"tiff\":\r\n        return \"image/tiff\";\r\n      case \"psd\":\r\n        return \"image/vnd.adobe.photoshop\";\r\n      case \"ai\":\r\n        return \"application/postscript\";\r\n      case \"eps\":\r\n        return \"application/postscript\";\r\n      case \"indd\":\r\n        return \"application/x-indesign\";\r\n      case \"raw\":\r\n        return \"image/x-raw\";\r\n      case \"cr2\":\r\n        return \"image/x-canon-cr2\";\r\n      case \"nef\":\r\n        return \"image/x-nikon-nef\";\r\n      case \"orf\":\r\n        return \"image/x-olympus-orf\";\r\n      case \"rw2\":\r\n        return \"image/x-panasonic-rw2\";\r\n      case \"pef\":\r\n        return \"image/x-pentax-pef\";\r\n      case \"arw\":\r\n        return \"image/x-sony-arw\";\r\n      case \"dng\":\r\n        return \"image/x-adobe-dng\";\r\n      case \"x3f\":\r\n        return \"image/x-sigma-x3f\";\r\n      case \"cr3\":\r\n        return \"image/x-canon-cr3\";\r\n      case \"heic\":\r\n        return \"image/heic\";\r\n      case \"heif\":\r\n        return \"image/heif\";\r\n      case \"avif\":\r\n        return \"image/avif\";\r\n  \r\n      // application\r\n      case \"pdf\":\r\n        return \"application/pdf\";\r\n      case \"txt\":\r\n        return \"text/plain\";\r\n  \r\n      // text\r\n      case \"html\":\r\n        return \"text/html\";\r\n      case \"css\":\r\n        return \"text/css\";\r\n      case \"js\":\r\n        return \"application/javascript\";\r\n      case \"json\":\r\n        return \"application/json\";\r\n      case \"xml\":\r\n        return \"application/xml\";\r\n  \r\n      // archive\r\n      case \"zip\":\r\n        return \"application/zip\";\r\n      case \"rar\":\r\n        return \"application/x-rar-compressed\";\r\n      case \"7z\":\r\n        return \"application/x-7z-compressed\";\r\n      default:\r\n        return \"application/octet-stream\";\r\n    }\r\n  }","import { Logger } from \"@/utils/logger\";\r\nimport { Time } from \"@/utils/time\";\r\nimport { tool } from \"ai\";\r\nimport { z } from \"zod\";\r\n\r\nexport const TaskHandler = {\r\n    /**\r\n     * Get the current date and time in real-time.\r\n     * This tool does not require any parameters. It returns the current time in a standard format.\r\n     */\r\n    getCurrentTime: tool({\r\n        description: \"Get the current date and time in real-time. This tool does not require any parameters. It returns the current time in a standard format. Use this tool when user ask you for current time or date or anything that related to time.\",\r\n        parameters: z.object({}),\r\n        execute: async () => await Tools.getCurrentTime(),\r\n    }),\r\n}\r\n\r\n\r\nexport class Tools {\r\n\r\n    /**\r\n     * Retrieves the current time in a human-readable format.\r\n     * This tool does not require any parameters.\r\n     */\r\n    public static async getCurrentTime() {\r\n        Logger.info(\"Retrieving current time...\");\r\n        return Time.getCurrentTimeToHumanReadable()\r\n    }\r\n}","import crypto, { randomUUID } from \"crypto\";\r\n\r\n\r\nexport function HashWithSHA256(data: string): string {\r\n  return crypto.createHash(\"sha256\").update(data).digest(\"hex\");\r\n}\r\n\r\nexport function GenerateUUID(): string {\r\n  return randomUUID();\r\n}\r\n\r\nexport function GenerateRandomString(length: number): string {\r\n  return crypto.randomBytes(length).toString(\"hex\").slice(0, length);\r\n}","import * as rl from \"node:readline/promises\";\r\nimport dotenv from \"dotenv\";\r\ndotenv.config();\r\n\r\nconst terminal = rl.createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout,\r\n  terminal: true,\r\n  completer: (line) => {\r\n    const completions = [\"help\", \"exit\", \"clear\"];\r\n    const hits = completions.filter((c) => c.startsWith(line));\r\n    return [hits.length ? hits : completions, line];\r\n  },\r\n});\r\n\r\n/**\r\n * Prompts the user for input and returns the response.\r\n * @param question The question to ask the user.\r\n * @returns A promise that resolves to the user's input.\r\n */\r\nexport async function Question(question?: string): Promise<string> {\r\n  return terminal.question(question ? question + \": \" : \": \");\r\n}\r\n\r\n/**\r\n * Prompts the user for input and returns the response.\r\n * @returns A promise that resolves to the user's input.\r\n */\r\nexport async function CloseTerminal() {\r\n  await terminal.close();\r\n  process.exit(0);\r\n}\r\n\r\n/**\r\n * Clears the terminal screen.\r\n * @returns A promise that resolves to the user's input.\r\n */\r\nexport async function ClearTerminal() {\r\n  process.stdout.write(\"\\x1Bc\");\r\n  return terminal.prompt();\r\n}\r\n\r\n/**\r\n * Pauses execution for a specified duration (in seconds), similar to Python's sleep.\r\n * @param duration The number of seconds to sleep.\r\n * @returns A promise that resolves after the specified duration.\r\n */\r\nexport async function Sleep(duration: number): Promise<void> {\r\n  return new Promise((resolve) => setTimeout(resolve, duration * 1000));\r\n}\r\n\r\nexport async function Help() {\r\n  console.log(`\r\nAvailable commands:\r\n  - help: Show this help message\r\n  - exit: Exit the terminal\r\n  - clear: Clear the terminal screen\r\n  `);\r\n  return terminal.prompt();\r\n}\r\n\r\n\r\n/**\r\n * Parses environment variables that start with a given prefix.\r\n * @param prefix The prefix to filter environment variables.\r\n * @returns An object containing arrays of keys and values.\r\n */\r\nexport function ParseEnvKeys(prefix: string): { keys: string[]; values: string[] } {\r\n  const envKeys = Object.keys(process.env).filter((key) =>\r\n    key.startsWith(prefix)\r\n  );\r\n  const keys: string[] = [];\r\n  const values: string[] = [];\r\n  \r\n  envKeys.forEach((key) => {\r\n    if (process.env[key]) {\r\n      keys.push(key);\r\n      values.push(process.env[key]!);\r\n    }\r\n  });\r\n\r\n  return { keys, values };\r\n}\r\n","import { ConversationDB, UserBase } from \"@/types\";\r\nimport { IOF } from \"@/lib/iof\";\r\nimport { CoreMessage } from \"ai\";\r\nimport { Time } from \"@/utils/time\";\r\n\r\ninterface SessionConfig {\r\n    /**\r\n     * The platform for the session, e.g., \"web\", \"mobile\", etc.\r\n     */\r\n    platform: string;\r\n    /**\r\n     * The folder name where session files are stored.\r\n     * Default is \"sessions\".\r\n     */\r\n    folderName?: string;\r\n}\r\n\r\n/**\r\n * Represents a session for an AI agent.\r\n * This class is used to manage the session configuration and operations.\r\n * It can be extended to implement specific session functionalities.\r\n */\r\nexport class AgentSession {\r\n    private platform: string;\r\n    private folderName: string = \"sessions\";\r\n    private sessionFilePrefix: string = \"session-\";\r\n    private userBase: UserBase | null = null;\r\n    private userSessionFileName: string | null = null;\r\n\r\n\r\n    /**\r\n     * Creates a new session with the specified configuration.\r\n     * @param config - The configuration for the session, including the platform.\r\n     */\r\n    constructor(config: SessionConfig) {\r\n        this.platform = config.platform;\r\n        this.folderName = config.folderName || this.folderName;\r\n        this.initPlatform().catch(error => {\r\n            throw new Error(error);\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Initializes the platform for the session.\r\n     * This method can be overridden to implement platform-specific initialization logic.\r\n     */\r\n    private async initPlatform() {\r\n        try {\r\n            const platform = this.platform;\r\n\r\n            if (!platform) {\r\n                throw new Error(\"Platform is required to initialize the session.\");\r\n            }\r\n            if (!await IOF.existsFile(`./${this.folderName}/platform.json`)) {\r\n                IOF.writeJSONFileOverwrite<{\r\n                    platform: string;\r\n                    createdAt: Date;\r\n                }>({\r\n                    filePath: `./${this.folderName}/platform.json`,\r\n                    data: [{ platform, createdAt: Time.getCurrentTime() }]\r\n                });\r\n            }\r\n        } catch (error) {\r\n            throw new Error(`Failed to initialize platform: ${error instanceof Error ? error.message : String(error)}`);\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts a new session for the user.\r\n     * If the session file does not exist, it creates a new one.\r\n     * If it exists, it resumes the session from the file.\r\n     * @param user - The user for whom the session is being started.\r\n     * @param folderName - The name of the folder where session files are stored.\r\n     * @returns An object containing the user and the session history.\r\n     */\r\n    public async useJSONFileSession(user: UserBase) {\r\n        if (!user) {\r\n            throw new Error(\"User is required to start a session.\");\r\n        }\r\n        this.userBase = user;\r\n        IOF.mkdir(`./${this.folderName}`);\r\n        const session = await this.resumeJSONFileSession(user);\r\n        if (session && session.session.length > 0) {\r\n            return session;\r\n        }\r\n        return await this.createNewJSONFileSession(user);\r\n    }\r\n\r\n    /**\r\n     * Saves the conversation history to a JSON file.\r\n     * @param data - The conversation data to be saved.\r\n     * @throws An error if the file cannot be written or if the content is not an array.\r\n     */\r\n    public async saveHistory(data: ConversationDB): Promise<void> {\r\n        if (!this.userBase) {\r\n            throw new Error(\"User must be set before saving history.\");\r\n        }\r\n        await IOF.writeJSONFile({\r\n            filePath: `./${this.folderName}/${this.sessionFilePrefix}${this.userBase?.username || this.userBase?.email || this.userBase?.phone || this.userBase?.name}.json`,\r\n            data: data\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Retrieves user data from a JSON file.\r\n     * If the user exists, it returns the user data; otherwise, it returns null.\r\n     * @param user - The user object containing the phone number to search for.\r\n     * @returns The user data if found, or null if not found.\r\n     */\r\n    public async getUserData(user: UserBase): Promise<UserBase | null> {\r\n        const usersFilePath = this.userSessionFileName || `./${this.folderName}/users.json`;\r\n        if (await IOF.existsFile(usersFilePath)) {\r\n            const history = await IOF.readJSONFile<UserBase>(usersFilePath);\r\n            const existingUser = history.find(u => u.phone === user.phone);\r\n            if (existingUser) {\r\n                return existingUser;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n    * Retrieves the conversation history from a JSON file.\r\n    * The history is sorted by message timestamp and response timestamp.\r\n    * @param filePath - The path to the JSON file containing the conversation history.\r\n    * @returns An array of CoreMessage objects representing the conversation history.\r\n    */\r\n    public async getHistory(filePath: string) {\r\n        const history = await IOF.readJSONFile<ConversationDB>(filePath)\r\n        if (!history || history.length === 0) {\r\n            return [];\r\n        }\r\n        history?.sort((a, b) => {\r\n            // Compare by messageTimestamp first (ascending order)\r\n            const messageTimestampComparison =\r\n                new Date(a.timestamp).getTime() -\r\n                new Date(b.timestamp).getTime();\r\n            if (messageTimestampComparison !== 0) {\r\n                return messageTimestampComparison;\r\n            }\r\n\r\n            // If messageTimestamp timestamps are equal, compare by responseTimestamp (ascending order)\r\n            const responseTimestampComparison =\r\n                new Date(a.timestamp || 0).getTime() -\r\n                new Date(b.timestamp || 0).getTime();\r\n            return responseTimestampComparison;\r\n        });\r\n\r\n        const message: CoreMessage[] = [];\r\n        history.forEach((item) => {\r\n            if (item.role === \"user\" && item.text) {\r\n                message.push({\r\n                    role: \"user\",\r\n                    content: [\r\n                        {\r\n                            type: \"text\",\r\n                            text: item.text,\r\n                        },\r\n                    ],\r\n                });\r\n            }\r\n            if (item.role === \"assistant\" && item.text) {\r\n                message.push({\r\n                    role: \"assistant\",\r\n                    content: [\r\n                        {\r\n                            type: \"text\",\r\n                            text: item.text,\r\n                        }\r\n                    ],\r\n                });\r\n            }\r\n        });\r\n\r\n        return message;\r\n    }\r\n\r\n\r\n    /**\r\n     * Starts a new session for the user.\r\n     * If the session file does not exist, it creates a new one.\r\n     * If it exists, it resumes the session from the file.\r\n     * @param user - The user for whom the session is being started.\r\n     * @returns An object containing the user and the session history.\r\n     */\r\n    private async createUserJSONFileSession(user: UserBase) {\r\n        if (!user) {\r\n            throw new Error(\"User is required to create a session.\");\r\n        }\r\n        const usersFilePath = `./${this.folderName}/users.json`;\r\n        this.userSessionFileName = usersFilePath;\r\n        // Ensure the users file exists and read existing users\r\n        IOF.mkdir(`./${this.folderName}`);\r\n\r\n        let users: UserBase[] = [];\r\n        if (IOF.existsFileSync(usersFilePath)) {\r\n            users = await IOF.readJSONFile<UserBase>(usersFilePath);\r\n            const existingUser = users.find(u => u.username === user.username || u.email === user.email || u.phone === user.phone || u.name === user.name);\r\n            if (existingUser) {\r\n                return existingUser;\r\n            }\r\n            users.push(user);\r\n            await IOF.writeJSONFileOverwrite({\r\n                filePath: usersFilePath,\r\n                data: users\r\n            });\r\n            return user;\r\n        } else {\r\n            await IOF.writeJSONFileOverwrite({\r\n                filePath: usersFilePath,\r\n                data: [user]\r\n            });\r\n            return user;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts a new session for the user.\r\n     * If the session file does not exist, it creates a new one.\r\n     * If it exists, it resumes the session from the file.\r\n     * @param user - The user for whom the session is being started.\r\n     * @returns An object containing the user and the session history.\r\n     */\r\n    private async createNewJSONFileSession(user: UserBase) {\r\n        try {\r\n            if (!user) {\r\n                throw new Error(\"User is required to create a session.\");\r\n            }\r\n            const userSession = await this.createUserJSONFileSession(user);\r\n            const filePath = `./${this.folderName}/${this.sessionFilePrefix}${user.username || user.email || user.phone || user.name}.json`;\r\n\r\n            await IOF.writeJSONFileOverwrite({ filePath, data: [] as CoreMessage[] });\r\n            return {\r\n                user: userSession,\r\n                session: [] as CoreMessage[]\r\n            }\r\n        } catch (error) {\r\n            throw new Error(`Failed to create new session for user ${user.username || user.email || user.phone || user.name}: ${error instanceof Error ? error.message : String(error)}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resumes the session from a JSON file.\r\n     * If the file does not exist or is empty, it returns an empty array.\r\n     * @param user - The user for whom the session is being resumed.\r\n     * @returns An array of CoreMessages from the JSON file.\r\n     */\r\n    private async resumeJSONFileSession(user: UserBase) {\r\n        try {\r\n            const history = await this.getHistory(`./${this.folderName}/${this.sessionFilePrefix}${user.username || user.email || user.phone || user.name}.json`);\r\n            return {\r\n                user: user,\r\n                session: history\r\n            };\r\n        } catch (error) {\r\n            if (error instanceof Error && error.message.includes(\"File not found\")) {\r\n                return {\r\n                    user: user,\r\n                    session: []\r\n                };\r\n            }\r\n            throw new Error(`Failed to resume session for user ${user.username || user.email || user.phone || user.name}: ${error instanceof Error ? error.message : String(error)}`);\r\n        }\r\n    }\r\n}","export * from \"@/core/agent\"\r\nexport * from \"@/core/tools\"\r\nexport * from \"@/lib/iof\"\r\nexport * from \"@/utils/colors\"\r\nexport * from \"@/utils/hash\"\r\nexport * from \"@/utils/logger\"\r\nexport * from \"@/utils/mimeType\"\r\nexport * as Terminal from \"@/utils/terminal\"\r\nexport * from \"@/utils/time\"\r\nexport * from \"@/lib/session\"\r\nexport { CoreMessage } from \"ai\"\r\nexport * from \"@/types/index\""],"mappings":"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CL,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA;AAAA,IAGT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA;AAAA,IAGT,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA;AAAA,IAGT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA;AAAA,IAGT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IA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","names":["openAIModel","text","response","crypto","resolve","CoreMessage"]}